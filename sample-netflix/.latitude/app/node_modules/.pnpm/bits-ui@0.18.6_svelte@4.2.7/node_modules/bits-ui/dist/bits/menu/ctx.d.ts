/// <reference types="svelte" />
import { type CreateDropdownSubmenuProps as DropdownSubmenuProps, type CreateMenuRadioGroupProps as DropdownRadioGroupProps, type CreateDropdownMenuCheckboxItemProps as DropdownCheckboxItemProps, type CreateDropdownMenuProps } from "@melt-ui/svelte";
import type { Writable } from "svelte/store";
import type { FloatingProps } from "../floating/_types.js";
export declare function getMenuData(): {
    NAME: "menu";
    SUB_NAME: string;
    RADIO_GROUP_NAME: string;
    CHECKBOX_ITEM_NAME: string;
    RADIO_ITEM_NAME: string;
    GROUP_NAME: string;
    PARTS: readonly ["arrow", "checkbox-indicator", "checkbox-item", "content", "group", "item", "label", "radio-group", "radio-item", "radio-indicator", "separator", "sub-content", "sub-trigger", "trigger"];
};
type GetReturn = Omit<ReturnType<typeof setCtx>, "updateOption">;
type GetSubReturn = Omit<ReturnType<typeof setSubMenuCtx>, "updateOption">;
export declare function getCtx(): GetReturn;
export declare function setCtx(props: CreateDropdownMenuProps): {
    updateOption: <K extends string, V extends unknown>(key: K, value: V | undefined) => void;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
    ids: import("@melt-ui/svelte/internal/helpers").ToWritableStores<{
        menu: string;
        trigger: string;
    }>;
    elements: {
        trigger: import("@melt-ui/svelte/internal/helpers").MeltElement<[import("@melt-ui/svelte/internal/helpers").WithGet<Writable<boolean>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "pointerdown">, ([$rootOpen, $rootMenuId, $rootTriggerId]: [boolean, string, string]) => {
            readonly 'aria-controls': string;
            readonly 'aria-expanded': boolean;
            readonly 'data-state': "open" | "closed";
            readonly id: string;
            readonly tabindex: 0;
        }, string>;
        menu: import("@melt-ui/svelte/internal/helpers").MeltElement<[import("svelte/store").Readable<boolean>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string | HTMLElement | null | undefined>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown">, ([$isVisible, $portal, $rootMenuId, $rootTriggerId]: [boolean, string | HTMLElement | null | undefined, string, string]) => {
            readonly role: "menu";
            readonly hidden: true | undefined;
            readonly style: string;
            readonly id: string;
            readonly 'aria-labelledby': string;
            readonly 'data-state': "open" | "closed";
            readonly 'data-portal': string | HTMLElement | undefined;
            readonly tabindex: -1;
        }, string>;
        item: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, () => {
            role: string;
            tabindex: number;
            'data-orientation': string;
        }, string>;
        arrow: import("@melt-ui/svelte/internal/helpers").MeltElement<import("@melt-ui/svelte/internal/helpers").WithGet<Writable<number | undefined>>, import("svelte/action").Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
            'data-arrow': boolean;
            style: string;
        }, string>;
        separator: import("@melt-ui/svelte/internal/helpers").MeltElement<[import("@melt-ui/svelte/internal/helpers").WithGet<Writable<import("@melt-ui/svelte/internal/types").Orientation>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<boolean>>], import("svelte/action").Action<any, any, Record<never, any>>, ([$orientation, $decorative]: [import("@melt-ui/svelte/internal/types").Orientation, boolean]) => {
            role: string;
            'aria-orientation': "vertical" | undefined;
            'aria-hidden': boolean;
            'data-orientation': import("@melt-ui/svelte/internal/types").Orientation;
        }, "separator">;
        group: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => (groupId: string) => {
            role: string;
            'aria-labelledby': string;
        }, string>;
        groupLabel: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => (groupId: string) => {
            id: string;
        }, string>;
    };
    states: {
        open: {
            update: (updater: import("svelte/store").Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<boolean>, invalidate?: import("svelte/store").Invalidator<boolean> | undefined): import("svelte/store").Unsubscriber;
            get: () => boolean;
            destroy?: (() => void) | undefined;
        };
    };
    builders: {
        createCheckboxItem: (props?: import("@melt-ui/svelte/dist/builders/menu/types.js")._CheckboxItemProps | undefined) => {
            elements: {
                checkboxItem: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
                    update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                    set: (this: void, value: boolean | "indeterminate") => void;
                    subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
                    get: () => boolean | "indeterminate";
                    destroy?: (() => void) | undefined;
                }, Writable<boolean>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, ([$checked, $disabled]: [boolean | "indeterminate", boolean]) => {
                    readonly role: "menuitemcheckbox";
                    readonly tabindex: -1;
                    readonly 'data-orientation': "vertical";
                    readonly 'aria-checked': "false" | "true" | "mixed";
                    readonly 'data-disabled': true | undefined;
                    readonly 'data-state': "checked" | "unchecked" | "indeterminate";
                }, string>;
            };
            states: {
                checked: {
                    update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                    set: (this: void, value: boolean | "indeterminate") => void;
                    subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
                    get: () => boolean | "indeterminate";
                    destroy?: (() => void) | undefined;
                };
            };
            helpers: {
                isChecked: import("svelte/store").Readable<boolean>;
                isIndeterminate: import("svelte/store").Readable<boolean>;
            };
            options: {
                disabled: Writable<boolean>;
            };
        };
        createSubmenu: (args?: import("@melt-ui/svelte/dist/builders/menu/types.js")._CreateSubmenuProps | undefined) => {
            ids: import("@melt-ui/svelte/internal/helpers").ToWritableStores<{
                menu: string;
                trigger: string;
            }>;
            elements: {
                subTrigger: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
                    update: (updater: import("svelte/store").Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
                    set: (this: void, value: boolean) => void;
                    subscribe(this: void, run: import("svelte/store").Subscriber<boolean>, invalidate?: import("svelte/store").Invalidator<boolean> | undefined): import("svelte/store").Unsubscriber;
                    get: () => boolean;
                    destroy?: (() => void) | undefined;
                }, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<boolean>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerleave" | "pointermove">, ([$subOpen, $disabled, $subMenuId, $subTriggerId]: [boolean, boolean, string, string]) => {
                    readonly role: "menuitem";
                    readonly id: string;
                    readonly tabindex: -1;
                    readonly 'aria-controls': string;
                    readonly 'aria-expanded': boolean;
                    readonly 'data-state': "open" | "closed";
                    readonly 'data-disabled': true | undefined;
                    readonly 'aria-haspopop': "menu";
                }, string>;
                subMenu: import("@melt-ui/svelte/internal/helpers").MeltElement<[import("svelte/store").Readable<boolean>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "focusout" | "pointermove">, ([$subIsVisible, $subMenuId, $subTriggerId]: [boolean, string, string]) => {
                    readonly role: "menu";
                    readonly hidden: true | undefined;
                    readonly style: string;
                    readonly id: string;
                    readonly 'aria-labelledby': string;
                    readonly 'data-state': "open" | "closed";
                    readonly 'data-id': string;
                    readonly tabindex: -1;
                }, string>;
                subArrow: import("@melt-ui/svelte/internal/helpers").MeltElement<import("@melt-ui/svelte/internal/helpers").WithGet<Writable<number>>, import("svelte/action").Action<any, any, Record<never, any>>, ($arrowSize: number) => {
                    'data-arrow': boolean;
                    style: string;
                }, string>;
            };
            states: {
                subOpen: {
                    update: (updater: import("svelte/store").Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
                    set: (this: void, value: boolean) => void;
                    subscribe(this: void, run: import("svelte/store").Subscriber<boolean>, invalidate?: import("svelte/store").Invalidator<boolean> | undefined): import("svelte/store").Unsubscriber;
                    get: () => boolean;
                    destroy?: (() => void) | undefined;
                };
            };
            options: import("@melt-ui/svelte/internal/helpers").ToWritableStores<Omit<{
                open?: Writable<boolean> | undefined;
                ids?: Partial<{
                    menu: string;
                    trigger: string;
                }> | undefined;
                onOpenChange?: import("@melt-ui/svelte/internal/helpers").ChangeFn<boolean> | undefined;
                positioning: import("@melt-ui/svelte/internal/actions").FloatingConfig | {
                    placement: "right-start";
                    gutter: number;
                };
                arrowSize: number;
                disabled: boolean;
                preventScroll: true;
                closeOnEscape: true;
                closeOnOutsideClick: true;
                portal: undefined;
                loop: false;
                dir: "ltr";
                defaultOpen: false;
                typeahead: true;
                closeOnItemClick: true;
                onOutsideClick: undefined;
            }, "ids">>;
        };
        createMenuRadioGroup: (args?: import("@melt-ui/svelte/dist/builders/menu/types.js")._CreateRadioGroupProps | undefined) => {
            elements: {
                radioGroup: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => {
                    role: string;
                }, string>;
                radioItem: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
                    update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                    set: (this: void, value: string | null) => void;
                    subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
                    get: () => string | null;
                    destroy?: (() => void) | undefined;
                }], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: import("@melt-ui/svelte/dist/builders/menu/types.js")._RadioItemProps) => {
                    disabled: boolean;
                    role: string;
                    'data-state': string;
                    'aria-checked': boolean;
                    'data-disabled': boolean | undefined;
                    'data-value': string;
                    'data-orientation': string;
                    tabindex: number;
                }, string>;
            };
            states: {
                value: {
                    update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                    set: (this: void, value: string | null) => void;
                    subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
                    get: () => string | null;
                    destroy?: (() => void) | undefined;
                };
            };
            helpers: {
                isChecked: import("svelte/store").Readable<(itemValue: string) => boolean>;
            };
        };
    };
    options: import("@melt-ui/svelte/internal/helpers").ToWritableStores<Omit<{
        positioning: import("@melt-ui/svelte/internal/actions").FloatingConfig | {
            placement: "bottom";
        };
        arrowSize: number;
        dir: import("@melt-ui/svelte/internal/types").TextDirection;
        preventScroll: boolean;
        closeOnEscape: boolean;
        closeOnItemClick: boolean;
        portal: string | HTMLElement | null | undefined;
        closeOnOutsideClick: boolean;
        onOutsideClick: ((event: import("@melt-ui/svelte/index.js").InteractOutsideEvent) => void) | undefined;
        loop: boolean;
        defaultOpen: boolean;
        open?: Writable<boolean> | undefined;
        onOpenChange?: import("@melt-ui/svelte/internal/helpers").ChangeFn<boolean> | undefined;
        forceVisible: boolean;
        typeahead: boolean;
        closeFocus: import("@melt-ui/svelte/index.js").FocusProp | undefined;
        disableFocusFirstItem: boolean;
        ids?: Partial<{
            menu: string;
            trigger: string;
        }> | undefined;
    }, "ids">>;
};
export declare function setSubMenuCtx(props: DropdownSubmenuProps): {
    updateOption: <K extends string, V extends unknown>(key: K, value: V | undefined) => void;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
    ids: import("@melt-ui/svelte/internal/helpers").ToWritableStores<{
        menu: string;
        trigger: string;
    }>;
    elements: {
        subTrigger: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
            update: (updater: import("svelte/store").Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<boolean>, invalidate?: import("svelte/store").Invalidator<boolean> | undefined): import("svelte/store").Unsubscriber;
            get: () => boolean;
            destroy?: (() => void) | undefined;
        }, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<boolean>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerleave" | "pointermove">, ([$subOpen, $disabled, $subMenuId, $subTriggerId]: [boolean, boolean, string, string]) => {
            readonly role: "menuitem";
            readonly id: string;
            readonly tabindex: -1;
            readonly 'aria-controls': string;
            readonly 'aria-expanded': boolean;
            readonly 'data-state': "open" | "closed";
            readonly 'data-disabled': true | undefined;
            readonly 'aria-haspopop': "menu";
        }, string>;
        subMenu: import("@melt-ui/svelte/internal/helpers").MeltElement<[import("svelte/store").Readable<boolean>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>, import("@melt-ui/svelte/internal/helpers").WithGet<Writable<string>>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "focusout" | "pointermove">, ([$subIsVisible, $subMenuId, $subTriggerId]: [boolean, string, string]) => {
            readonly role: "menu";
            readonly hidden: true | undefined;
            readonly style: string;
            readonly id: string;
            readonly 'aria-labelledby': string;
            readonly 'data-state': "open" | "closed";
            readonly 'data-id': string;
            readonly tabindex: -1;
        }, string>;
        subArrow: import("@melt-ui/svelte/internal/helpers").MeltElement<import("@melt-ui/svelte/internal/helpers").WithGet<Writable<number>>, import("svelte/action").Action<any, any, Record<never, any>>, ($arrowSize: number) => {
            'data-arrow': boolean;
            style: string;
        }, string>;
    };
    states: {
        subOpen: {
            update: (updater: import("svelte/store").Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<boolean>, invalidate?: import("svelte/store").Invalidator<boolean> | undefined): import("svelte/store").Unsubscriber;
            get: () => boolean;
            destroy?: (() => void) | undefined;
        };
    };
    options: import("@melt-ui/svelte/internal/helpers").ToWritableStores<Omit<{
        open?: Writable<boolean> | undefined;
        ids?: Partial<{
            menu: string;
            trigger: string;
        }> | undefined;
        onOpenChange?: import("@melt-ui/svelte/internal/helpers").ChangeFn<boolean> | undefined;
        positioning: import("@melt-ui/svelte/internal/actions").FloatingConfig | {
            placement: "right-start";
            gutter: number;
        };
        arrowSize: number;
        disabled: boolean;
        preventScroll: true;
        closeOnEscape: true;
        closeOnOutsideClick: true;
        portal: undefined;
        loop: false;
        dir: "ltr";
        defaultOpen: false;
        typeahead: true;
        closeOnItemClick: true;
        onOutsideClick: undefined;
    }, "ids">>;
};
export declare function setRadioGroupCtx(props: DropdownRadioGroupProps): {
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
    elements: {
        radioGroup: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => {
            role: string;
        }, string>;
        radioItem: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
            update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
            set: (this: void, value: string | null) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            get: () => string | null;
            destroy?: (() => void) | undefined;
        }], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: import("@melt-ui/svelte/dist/builders/menu/types.js")._RadioItemProps) => {
            disabled: boolean;
            role: string;
            'data-state': string;
            'aria-checked': boolean;
            'data-disabled': boolean | undefined;
            'data-value': string;
            'data-orientation': string;
            tabindex: number;
        }, string>;
    };
    states: {
        value: {
            update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
            set: (this: void, value: string | null) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            get: () => string | null;
            destroy?: (() => void) | undefined;
        };
    };
    helpers: {
        isChecked: import("svelte/store").Readable<(itemValue: string) => boolean>;
    };
};
export declare function setRadioItem(value: string): {
    value: string;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
    elements: {
        radioGroup: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => {
            role: string;
        }, string>;
        radioItem: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
            update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
            set: (this: void, value: string | null) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            get: () => string | null;
            destroy?: (() => void) | undefined;
        }], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: import("@melt-ui/svelte/dist/builders/menu/types.js")._RadioItemProps) => {
            disabled: boolean;
            role: string;
            'data-state': string;
            'aria-checked': boolean;
            'data-disabled': boolean | undefined;
            'data-value': string;
            'data-orientation': string;
            tabindex: number;
        }, string>;
    };
    states: {
        value: {
            update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
            set: (this: void, value: string | null) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            get: () => string | null;
            destroy?: (() => void) | undefined;
        };
    };
    helpers: {
        isChecked: import("svelte/store").Readable<(itemValue: string) => boolean>;
    };
};
export declare function getRadioIndicator(): {
    value: string;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
    elements: {
        radioGroup: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => {
            role: string;
        }, string>;
        radioItem: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
            update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
            set: (this: void, value: string | null) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            get: () => string | null;
            destroy?: (() => void) | undefined;
        }], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: import("@melt-ui/svelte/dist/builders/menu/types.js")._RadioItemProps) => {
            disabled: boolean;
            role: string;
            'data-state': string;
            'aria-checked': boolean;
            'data-disabled': boolean | undefined;
            'data-value': string;
            'data-orientation': string;
            tabindex: number;
        }, string>;
    };
    states: {
        value: {
            update: (updater: import("svelte/store").Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
            set: (this: void, value: string | null) => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<string | null>, invalidate?: import("svelte/store").Invalidator<string | null> | undefined): import("svelte/store").Unsubscriber;
            get: () => string | null;
            destroy?: (() => void) | undefined;
        };
    };
    helpers: {
        isChecked: import("svelte/store").Readable<(itemValue: string) => boolean>;
    };
};
export declare function getSubTrigger(): GetSubReturn;
export declare function getSubmenuCtx(): GetSubReturn;
export declare function setCheckboxItem(props: DropdownCheckboxItemProps): {
    updateOption: <K extends string, V extends unknown>(key: K, value: V | undefined) => void;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
    elements: {
        checkboxItem: import("@melt-ui/svelte/internal/helpers").MeltElement<[{
            update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
            set: (this: void, value: boolean | "indeterminate") => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
            get: () => boolean | "indeterminate";
            destroy?: (() => void) | undefined;
        }, Writable<boolean>], (node: HTMLElement) => import("@melt-ui/svelte/internal/types").MeltActionReturn<"keydown" | "click" | "focusin" | "focusout" | "pointerdown" | "pointerleave" | "pointermove">, ([$checked, $disabled]: [boolean | "indeterminate", boolean]) => {
            readonly role: "menuitemcheckbox";
            readonly tabindex: -1;
            readonly 'data-orientation': "vertical";
            readonly 'aria-checked': "false" | "true" | "mixed";
            readonly 'data-disabled': true | undefined;
            readonly 'data-state': "checked" | "unchecked" | "indeterminate";
        }, string>;
    };
    states: {
        checked: {
            update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
            set: (this: void, value: boolean | "indeterminate") => void;
            subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
            get: () => boolean | "indeterminate";
            destroy?: (() => void) | undefined;
        };
    };
    helpers: {
        isChecked: import("svelte/store").Readable<boolean>;
        isIndeterminate: import("svelte/store").Readable<boolean>;
    };
    options: {
        disabled: Writable<boolean>;
    };
};
export declare function getCheckboxIndicator(): {
    update: (updater: import("svelte/store").Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
    set: (this: void, value: boolean | "indeterminate") => void;
    subscribe(this: void, run: import("svelte/store").Subscriber<boolean | "indeterminate">, invalidate?: import("svelte/store").Invalidator<boolean | "indeterminate"> | undefined): import("svelte/store").Unsubscriber;
    get: () => boolean | "indeterminate";
    destroy?: (() => void) | undefined;
};
export declare function setGroupCtx(): {
    group: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => (groupId: string) => {
        role: string;
        'aria-labelledby': string;
    }, string>;
    id: string;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
};
export declare function getGroupLabel(): {
    groupLabel: import("@melt-ui/svelte/internal/helpers").MeltElement<import("svelte/store").Stores | undefined, import("svelte/action").Action<any, any, Record<never, any>>, () => (groupId: string) => {
        id: string;
    }, string>;
    id: string;
    getAttrs: (part: "content" | "checkbox-indicator" | "label" | "arrow" | "group" | "radio-group" | "separator" | "item" | "trigger" | "checkbox-item" | "radio-item" | "radio-indicator" | "sub-content" | "sub-trigger") => Record<string, string>;
};
export declare function setArrow(size?: number): GetReturn;
export declare function updatePositioning(props: FloatingProps): void;
export declare function updateSubPositioning(props: FloatingProps): void;
export {};
