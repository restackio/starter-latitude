import { BaseConnector, ConnectorError } from '@latitude-data/base-connector';
import QueryResult, { DataType } from '@latitude-data/query_result';
import pkg from 'sqlite3';

const { Database, OPEN_READONLY, OPEN_READWRITE } = pkg;
class SqliteConnector extends BaseConnector {
    url;
    constructor(rootPath, connectionParams) {
        super(rootPath);
        this.url = connectionParams.url || ':memory:';
    }
    resolve(value) {
        return {
            value,
            resolvedAs: '?',
        };
    }
    async runQuery(query) {
        try {
            const client = new Database(this.url, this.url === ':memory:' ? OPEN_READWRITE : OPEN_READONLY, (err) => {
                if (err) {
                    throw new ConnectorError(err.message);
                }
            });
            const results = await new Promise((resolve, reject) => {
                client.serialize(() => {
                    client.all(query.sql, this.buildQueryParams(query.params), (err, results) => {
                        if (err) {
                            reject(err);
                        }
                        client.close();
                        resolve(results);
                    });
                });
            });
            const rows = results.map((row) => Object.values(row));
            const rowCount = results.length;
            const firstRow = results[0];
            const fields = firstRow
                ? this.inferDataTypes(firstRow)
                : [];
            return new QueryResult({ fields, rows, rowCount });
        }
        catch (error) {
            throw new ConnectorError(error.message);
        }
    }
    buildQueryParams(params) {
        return params.map((param) => param.value);
    }
    inferDataTypes(row) {
        const fields = [];
        for (const [key, value] of Object.entries(row)) {
            const type = typeof value;
            // IMPORTANT: Order matters
            if (type === 'number') {
                if (Number.isInteger(value)) {
                    fields.push({ name: key, type: DataType.Integer });
                }
                else {
                    fields.push({ name: key, type: DataType.Float });
                }
            }
            else if (type === 'boolean') {
                fields.push({ name: key, type: DataType.Boolean });
            }
            else if (!isNaN(Date.parse(value))) {
                fields.push({ name: key, type: DataType.Datetime });
            }
            else if (type === 'string') {
                fields.push({ name: key, type: DataType.String });
            }
            else {
                fields.push({ name: key, type: DataType.Unknown });
            }
        }
        return fields;
    }
}

export { SqliteConnector };
//# sourceMappingURL=index.js.map
