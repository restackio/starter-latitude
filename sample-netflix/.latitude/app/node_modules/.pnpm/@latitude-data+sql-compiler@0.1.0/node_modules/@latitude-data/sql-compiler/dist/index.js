import { locate } from 'locate-character';
import { isIdentifierStart, isIdentifierChar } from 'acorn';
import * as code_red from 'code-red';

class CompileError extends Error {
    code;
    start;
    end;
    pos;
    frame;
    toString() {
        if (!this.start)
            return this.message;
        return `${this.message} (${this.start.line}:${this.start.column})\n${this.frame}`;
    }
}
function tabsToSpaces(str) {
    return str.replace(/^\t+/, (match) => match.split('\t').join('  '));
}
function getCodeFrame(source, line, startColumn, endColumn) {
    const lines = source.split('\n');
    const frameStart = Math.max(0, line - 2);
    const frameEnd = Math.min(line + 3, lines.length);
    const digits = String(frameEnd + 1).length;
    return lines
        .slice(frameStart, frameEnd)
        .map((str, i) => {
        const isErrorLine = frameStart + i === line;
        const lineNum = String(i + frameStart + 1).padStart(digits, ' ');
        if (isErrorLine) {
            const indicator = ' '.repeat(digits + 2 + tabsToSpaces(str.slice(0, startColumn)).length) +
                '^' +
                '~'.repeat(endColumn ? Math.max(0, endColumn - startColumn - 1) : 0);
            return `${lineNum}: ${tabsToSpaces(str)}\n\n${indicator}`;
        }
        return `${lineNum}: ${tabsToSpaces(str)}`;
    })
        .join('\n');
}
function error(message, props) {
    const error = new CompileError(message);
    error.name = props.name;
    const start = locate(props.source, props.start, { offsetLine: 1 });
    const end = locate(props.source, props.end || props.start, { offsetLine: 1 });
    error.code = props.code;
    error.start = start;
    error.end = end;
    error.pos = props.start;
    error.frame = getCodeFrame(props.source, (start?.line ?? 1) - 1, start?.column ?? 0, end?.column);
    throw error;
}

var errors = {
    unexpectedEof: {
        code: 'unexpected-eof',
        message: 'Unexpected end of input',
    },
    unexpectedEofToken: (token) => ({
        code: 'unexpected-eof',
        message: `Unexpected '${token}'`,
    }),
    unexpectedToken: (token) => ({
        code: 'unexpected-token',
        message: `Expected '${token}'`,
    }),
    unexpectedBlockClose: {
        code: 'unexpected-block-close',
        message: 'Unexpected block closing tag',
    },
    invalidElseif: {
        code: 'invalid-elseif',
        message: "'elseif' should be 'else if'",
    },
    invalidElseifPlacementUnclosedBlock: (block) => ({
        code: 'invalid-elseif-placement',
        message: `Expected to close ${block} before seeing {:else if ...} block`,
    }),
    invalidElseifPlacementOutsideIf: {
        code: 'invalid-elseif-placement',
        message: 'Cannot have an {:else if ...} block outside an {#if ...} block',
    },
    invalidElsePlacementUnclosedBlock: (block) => ({
        code: 'invalid-else-placement',
        message: `Expected to close ${block} before seeing {:else} block`,
    }),
    invalidElsePlacementOutsideIf: {
        code: 'invalid-else-placement',
        message: 'Cannot have an {:else} block outside an {#if ...} or {#each ...} block',
    },
    expectedBlockType: {
        code: 'expected-block-type',
        message: 'Expected if or each',
    },
    unexpectedTokenDestructure: {
        code: 'unexpected-token',
        message: 'Expected identifier or destructure pattern',
    },
    expectedName: {
        code: 'expected-name',
        message: 'Expected name',
    },
    unexpectedMustacheCloseTag: {
        code: 'unexpected-mustache-close-tag',
        message: 'Unexpected closing tag without matching opening tag',
    },
    unexpectedEndOfComment: {
        code: 'unexpected-end-of-comment',
        message: 'Unexpected end of comment',
    },
    // Compiler errors:
    queryNotFound: (name) => ({
        code: 'query-not-found',
        message: `Query '${name}' not found`,
    }),
    unsupportedBaseNodeType: (type) => ({
        code: 'unsupported-base-node-type',
        message: `Unsupported base node type: ${type}`,
    }),
    unsupportedExpressionType: (type) => ({
        code: 'unsupported-expression-type',
        message: `Unsupported expression type: ${type}`,
    }),
    invalidConstantDefinition: {
        code: 'invalid-constant-definition',
        message: 'Constant definitions must assign a value to a variable',
    },
    variableAlreadyDeclared: (name) => ({
        code: 'variable-already-declared',
        message: `Variable '${name}' is already declared`,
    }),
    variableNotDeclared: (name) => ({
        code: 'variable-not-declared',
        message: `Variable '${name}' is not declared`,
    }),
    invalidObjectKey: {
        code: 'invalid-object-key',
        message: 'Invalid object key',
    },
    unsupportedOperator: (operator) => ({
        code: 'unsupported-operator',
        message: `Unsupported operator: ${operator}`,
    }),
    constantReassignment: {
        code: 'constant-reassignment',
        message: 'Cannot reassign a constant',
    },
    unknownFunction: (name) => ({
        code: 'unknown-function',
        message: `Unknown function: ${name}`,
    }),
    functionCallError: (name, message) => ({
        code: 'function-call-error',
        message: `Error calling function '${name}': ${message}`,
    }),
    invalidFunctionResultInterpolation: {
        code: 'invalid-function-result-interpolation',
        message: 'Functions called for interpolation must return a string',
    },
};

// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js
function fullCharCodeAt(str, i) {
    const code = str.charCodeAt(i);
    if (code <= 0xd7ff || code >= 0xe000)
        return code;
    const next = str.charCodeAt(i + 1);
    return (code << 10) + next - 0x35fdc00;
}

const reserved = new Set([
    'arguments',
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'eval',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'implements',
    'import',
    'in',
    'instanceof',
    'interface',
    'let',
    'new',
    'null',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'static',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'yield',
]);

function dashComment(parser) {
    const start = parser.index;
    let data = '';
    while (parser.index < parser.template.length) {
        if (parser.matchRegex(/\n/)) {
            break;
        }
        data += parser.template[parser.index++];
    }
    const node = {
        start,
        end: parser.index,
        type: 'Comment',
        raw: data,
        data: data.substring(2)
    };
    parser.current().children.push(node);
}

function multiLineComment(parser) {
    if (parser.match('*/')) {
        parser.error(errors.unexpectedEndOfComment);
    }
    const start = parser.index;
    while (parser.index < parser.template.length) {
        if (parser.matchRegex(/\*\//)) {
            parser.index += 2;
            break;
        }
        parser.index++;
    }
    const data = parser.template.substring(start, parser.index);
    const node = {
        start,
        end: parser.index + 1,
        type: 'Comment',
        raw: data,
        data: data.substring(2, data.length - 2)
    };
    parser.current().children.push(node);
}

const parseExpressionAt = (source, index) => code_red.parseExpressionAt(source, index, {
    sourceType: 'module',
    ecmaVersion: 13,
    locations: true
});

function readExpression(parser) {
    try {
        const node = parseExpressionAt(parser.template, parser.index);
        let numParenthesis = 0;
        for (let i = parser.index; i < node.start; i += 1) {
            if (parser.template[i] === '(')
                numParenthesis += 1;
        }
        let index = node.end;
        while (numParenthesis > 0) {
            const char = parser.template[index];
            if (char === ')') {
                numParenthesis -= 1;
            }
            else if (!/\s/.test(char)) {
                parser.error(errors.unexpectedToken(')'), index);
            }
            index += 1;
        }
        parser.index = index;
        return node;
    }
    catch (err) {
        parser.acornError(err);
    }
}

const SQUARE_BRACKET_OPEN = '['.charCodeAt(0);
const SQUARE_BRACKET_CLOSE = ']'.charCodeAt(0);
const CURLY_BRACKET_OPEN = '{'.charCodeAt(0);
const CURLY_BRACKET_CLOSE = '}'.charCodeAt(0);
function isBracketOpen(code) {
    return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}
function isBracketClose(code) {
    return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}
function isBracketPair(open, close) {
    return ((open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE) ||
        (open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE));
}
function getBracketClose(open) {
    if (open === SQUARE_BRACKET_OPEN) {
        return SQUARE_BRACKET_CLOSE;
    }
    if (open === CURLY_BRACKET_OPEN) {
        return CURLY_BRACKET_CLOSE;
    }
}

// @ts-expect-error - no types for this package
function readContext(parser) {
    const start = parser.index;
    let i = parser.index;
    const code = fullCharCodeAt(parser.template, i);
    if (isIdentifierStart(code, true)) {
        return {
            type: 'Identifier',
            name: parser.readIdentifier(),
            start,
            end: parser.index
        };
    }
    if (!isBracketOpen(code)) {
        parser.error(errors.unexpectedTokenDestructure);
    }
    const bracketStack = [code];
    i += code <= 0xffff ? 1 : 2;
    while (i < parser.template.length) {
        const code = fullCharCodeAt(parser.template, i);
        if (isBracketOpen(code)) {
            bracketStack.push(code);
        }
        else if (isBracketClose(code)) {
            if (!isBracketPair(bracketStack[bracketStack.length - 1], code)) {
                parser.error(errors.unexpectedToken(String.fromCharCode(getBracketClose(bracketStack[bracketStack.length - 1]) ?? 0)));
            }
            bracketStack.pop();
            if (bracketStack.length === 0) {
                i += code <= 0xffff ? 1 : 2;
                break;
            }
        }
        i += code <= 0xffff ? 1 : 2;
    }
    parser.index = i;
    const patternString = parser.template.slice(start, i);
    try {
        // the length of the `space_with_newline` has to be start - 1
        // because we added a `(` in front of the pattern_string,
        // which shifted the entire string to right by 1
        // so we offset it by removing 1 character in the `space_with_newline`
        // to achieve that, we remove the 1st space encountered,
        // so it will not affect the `column` of the node
        let spaceWithNewLine = parser.template
            .slice(0, start)
            .replace(/[^\n]/g, ' ');
        const firstSpace = spaceWithNewLine.indexOf(' ');
        spaceWithNewLine =
            spaceWithNewLine.slice(0, firstSpace) + spaceWithNewLine.slice(firstSpace + 1);
        return parseExpressionAt(`${spaceWithNewLine}(${patternString} = 1)`, start - 1).left;
    }
    catch (error) {
        parser.acornError(error);
    }
    return {
        type: 'Identifier',
        name: '',
        start: parser.index,
        end: parser.index
    };
}

function mustache(parser) {
    if (parser.match('}')) {
        parser.error(errors.unexpectedMustacheCloseTag);
    }
    const start = parser.index;
    parser.index += 1;
    parser.allowWhitespace();
    // {/if}, {/each}, {/await} or {/key}
    if (parser.eat('/')) {
        let block = parser.current();
        let expected;
        if (block.type === 'ElseBlock') {
            block.end = start;
            parser.stack.pop();
            block = parser.current();
            expected = 'else';
        }
        if (block.type === 'IfBlock') {
            expected = 'if';
        }
        else if (block.type === 'EachBlock') {
            expected = 'each';
        }
        else {
            parser.error(errors.unexpectedBlockClose);
        }
        parser.eat(expected, true);
        parser.allowWhitespace();
        parser.eat('}', true);
        while (block.elseif) {
            block.end = parser.index;
            parser.stack.pop();
            block = parser.current();
            if (block.else) {
                block.else.end = start;
            }
        }
        // strip leading/trailing whitespace as necessary
        const charBefore = parser.template[block.start - 1];
        const charAfter = parser.template[parser.index];
        const trimBefore = !charBefore || /\s/.test(charBefore);
        const trimAfter = !charAfter || /\s/.test(charAfter);
        trimWhitespace(block, trimBefore, trimAfter);
        block.end = parser.index;
        parser.stack.pop();
    }
    else if (parser.eat(':else')) {
        if (parser.eat('if')) {
            parser.error(errors.invalidElseif);
        }
        parser.allowWhitespace();
        // :else if
        if (parser.eat('if')) {
            const block = parser.current();
            if (block.type !== 'IfBlock') {
                parser.error(parser.stack.some((block) => block.type === 'IfBlock')
                    ? errors.invalidElseifPlacementUnclosedBlock(toString(block))
                    : errors.invalidElseifPlacementOutsideIf);
            }
            parser.requireWhitespace();
            const expression = readExpression(parser);
            parser.allowWhitespace();
            parser.eat('}', true);
            block.else = {
                start: parser.index,
                end: null,
                type: 'ElseBlock',
                children: [
                    {
                        start: parser.index,
                        end: null,
                        type: 'IfBlock',
                        elseif: true,
                        expression,
                        children: []
                    }
                ]
            };
            parser.stack.push(block.else.children[0]);
        }
        else {
            // :else
            const block = parser.current();
            if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {
                parser.error(parser.stack.some((block) => block.type === 'IfBlock' || block.type === 'EachBlock')
                    ? errors.invalidElsePlacementUnclosedBlock(toString(block))
                    : errors.invalidElsePlacementOutsideIf);
            }
            parser.allowWhitespace();
            parser.eat('}', true);
            block.else = {
                start: parser.index,
                end: null,
                type: 'ElseBlock',
                children: []
            };
            parser.stack.push(block.else);
        }
    }
    else if (parser.eat('#')) {
        // {#if foo}, {#each foo} or {#await foo}
        const isIf = parser.eat('if');
        const isEach = parser.eat('each');
        if (!isIf && !isEach) {
            parser.error(errors.expectedBlockType);
        }
        const type = isIf ? 'IfBlock' : 'EachBlock';
        parser.requireWhitespace();
        const expression = readExpression(parser);
        const block = {
            start,
            end: start,
            type,
            expression,
            children: []
        };
        parser.allowWhitespace();
        // {#each} blocks must declare a context – {#each list as item}
        if (type === 'EachBlock') {
            parser.eat('as', true);
            parser.requireWhitespace();
            block['context'] = readContext(parser);
            parser.allowWhitespace();
            if (parser.eat(',')) {
                parser.allowWhitespace();
                block.index = parser.readIdentifier();
                if (!block.index)
                    parser.error(errors.expectedName);
                parser.allowWhitespace();
            }
            if (parser.eat('(')) {
                parser.allowWhitespace();
                block.key = readExpression(parser);
                parser.allowWhitespace();
                parser.eat(')', true);
                parser.allowWhitespace();
            }
        }
        parser.eat('}', true);
        parser.current().children.push(block);
        parser.stack.push(block);
    }
    else if (parser.eat('@const')) {
        // {@const a = b}
        parser.requireWhitespace();
        const expression = readExpression(parser);
        if (!(expression.type === 'AssignmentExpression' && expression.operator === '=')) {
            parser.error({
                code: 'invalid-const-args',
                message: '{@const ...} must be an assignment.'
            }, start);
        }
        parser.allowWhitespace();
        parser.eat('}', true);
        parser.current().children.push({
            start,
            end: parser.index,
            type: 'ConstTag',
            expression
        });
    }
    else {
        const expression = readExpression(parser);
        parser.allowWhitespace();
        parser.eat('}', true);
        parser.current().children.push({
            start,
            end: parser.index,
            type: 'MustacheTag',
            expression
        });
    }
}
function trimWhitespace(block, trimBefore = false, trimAfter = false) {
    if (!block.children || block.children.length === 0)
        return; // AwaitBlock
    const firstChild = block.children[0];
    const lastChild = block.children[block.children.length - 1];
    if (firstChild.type === 'Text' && trimBefore) {
        firstChild.data = firstChild.data.replace(/^[ \t\r\n]*/, '');
        if (!firstChild.data)
            block.children.shift();
    }
    if (lastChild.type === 'Text' && trimAfter) {
        lastChild.data = lastChild.data.replace(/[ \t\r\n]*$/, '');
        if (!lastChild.data)
            block.children.pop();
    }
    if (block.else) {
        trimWhitespace(block.else, trimBefore, trimAfter);
    }
    if (firstChild.elseif) {
        trimWhitespace(firstChild, trimBefore, trimAfter);
    }
}
function toString(node) {
    switch (node.type) {
        case 'IfBlock':
            return '{#if} block';
        case 'ElseBlock':
            return '{:else} block';
        case 'EachBlock':
            return '{#each} block';
        case 'ConstTag':
            return '{@const} tag';
        default:
            return node.type;
    }
}

const STRING_DELIMITERS_REGEX = /['"`]/;
function textInString(parser, char) {
    let data = '';
    while (parser.index < parser.template.length) {
        if (parser.match(char) && !parser.match(char.repeat(2)) && !data.match(/(?<!\\)(\\\\)*\\/)) {
            break;
        }
        data += parser.template[parser.index++];
    }
    parser.index++;
    return char + data + char;
}
const ENDS_WITH_ESCAPE_REGEX = /(?<!\\)(\\\\)*\\$/;
const RESERVED_DELIMITERS = ['{', '}', '--', '/*', '*/'];
function text(parser) {
    const start = parser.index;
    let data = '';
    while (parser.index < parser.template.length) {
        const isEscaping = ENDS_WITH_ESCAPE_REGEX.test(data);
        if (isEscaping)
            data = data.slice(0, -1); // Remove the escape character
        if (!isEscaping && RESERVED_DELIMITERS.some(sample => parser.match(sample))) {
            break;
        }
        if (!isEscaping && parser.matchRegex(STRING_DELIMITERS_REGEX)) {
            data += textInString(parser, parser.template[parser.index++]);
            continue;
        }
        data += parser.template[parser.index++];
    }
    const node = {
        start,
        end: parser.index,
        type: 'Text',
        raw: data,
        data: data.replace(/(?<!\\)\\{/g, '{').replace(/(?<!\\)\\}/g, '}')
    };
    parser.current().children.push(node);
}

function fragment(parser) {
    if (parser.match('{') || parser.match('}')) {
        return mustache;
    }
    if (parser.match('/*') || parser.match('*/')) {
        return multiLineComment;
    }
    if (parser.match('--')) {
        return dashComment;
    }
    return text;
}

function parse(template) {
    return new Parser(template).parse();
}
class Parser {
    template;
    index = 0;
    stack = [];
    constructor(template) {
        this.template = template;
    }
    parse() {
        const template = {
            start: 0,
            end: this.template.length,
            type: 'Fragment',
            children: [],
        };
        this.stack.push(template);
        let state = fragment;
        while (this.index < this.template.length) {
            state = state(this) || fragment;
        }
        if (this.stack.length > 1) {
            const current = this.current();
            this.error({
                code: `unclosed-block`,
                message: `Block was left open`,
            }, current.start);
        }
        if (state !== fragment) {
            this.error({
                code: `unexpected-eof`,
                message: `Unexpected end of input`,
            });
        }
        if (template.children.length) {
            let start = template.children[0].start;
            while (/\s/.test(template[start]))
                start += 1;
            let end = template.children[template.children.length - 1].end;
            while (/\s/.test(template[end - 1]))
                end -= 1;
            template.start = start;
            template.end = end;
        }
        else {
            template.start = template.end = null;
        }
        return template;
    }
    current() {
        return this.stack[this.stack.length - 1];
    }
    match(str) {
        return this.template.slice(this.index, this.index + str.length) === str;
    }
    allowWhitespace() {
        while (this.index < this.template.length &&
            /\s/.test(this.template[this.index] || '')) {
            this.index++;
        }
    }
    requireWhitespace() {
        if (!/\s/.test(this.template[this.index])) {
            this.error({
                code: 'missing-whitespace',
                message: 'Expected whitespace',
            });
        }
        this.allowWhitespace();
    }
    eat(str, required = false, error) {
        if (this.match(str)) {
            this.index += str.length;
            return true;
        }
        if (required) {
            this.error(error ||
                (this.index === this.template.length
                    ? errors.unexpectedEofToken(str)
                    : errors.unexpectedToken(str)));
        }
        return false;
    }
    error({ code, message }, index = this.index) {
        error(message, {
            name: 'ParseError',
            code,
            source: this.template,
            start: index - 1,
        });
    }
    acornError(err) {
        this.error({
            code: 'parse-error',
            message: err.message.replace(/ \(\d+:\d+\)$/, ''),
        }, err.pos);
    }
    matchRegex(pattern) {
        const match = pattern.exec(this.template.slice(this.index));
        if (!match || match.index !== 0)
            return null;
        return match[0];
    }
    read(pattern) {
        const result = this.matchRegex(pattern);
        if (result)
            this.index += result.length;
        return result;
    }
    readIdentifier(allowReserved = false) {
        const start = this.index;
        let i = this.index;
        const code = fullCharCodeAt(this.template, i);
        if (!isIdentifierStart(code, true))
            return null;
        i += code <= 0xffff ? 1 : 2;
        while (i < this.template.length) {
            const code = fullCharCodeAt(this.template, i);
            if (!isIdentifierChar(code, true))
                break;
            i += code <= 0xffff ? 1 : 2;
        }
        const identifier = this.template.slice(this.index, (this.index = i));
        if (!allowReserved && reserved.has(identifier)) {
            this.error({
                code: 'unexpected-reserved-word',
                message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`,
            }, start);
        }
        return identifier;
    }
}

// https://github.com/estree/estree/blob/master/es5.md#binary-operations
const BINARY_OPERATOR_METHODS = {
    // BinaryExpression
    '==': (left, right) => left == right,
    '!=': (left, right) => left != right,
    '===': (left, right) => left === right,
    '!==': (left, right) => left !== right,
    '<': (left, right) => left < right,
    '<=': (left, right) => left <= right,
    '>': (left, right) => left > right,
    '>=': (left, right) => left >= right,
    '<<': (left, right) => left << right,
    '>>': (left, right) => left >> right,
    '>>>': (left, right) => left >>> right,
    '+': (left, right) => left + right,
    '-': (left, right) => left - right,
    '*': (left, right) => left * right,
    '/': (left, right) => left / right,
    '%': (left, right) => left % right,
    '|': (left, right) => left | right,
    '^': (left, right) => left ^ right,
    '&': (left, right) => left & right,
    in: (left, right) => left in right,
    instanceof: (left, right) => left instanceof right,
    // LogicalExpression
    '||': (left, right) => left || right,
    '&&': (left, right) => left && right,
    '??': (left, right) => left ?? right,
};
// https://github.com/estree/estree/blob/master/es5.md#unary-operations
const UNARY_OPERATOR_METHODS = {
    // UnaryExpression
    '-': (value, prefix) => (prefix ? -value : value),
    '+': (value, prefix) => (prefix ? +value : value),
    '!': (value, _) => !value,
    '~': (value, _) => ~value,
    typeof: (value, _) => typeof value,
    void: (value, _) => void value,
};
// https://github.com/estree/estree/blob/master/es5.md#memberexpression
const MEMBER_EXPRESSION_METHOD = (object, property) => object[property];
// https://github.com/estree/estree/blob/master/es5.md#assignmentexpression
const ASSIGNMENT_OPERATOR_METHODS = {
    '+=': (left, right) => (left += right),
    '-=': (left, right) => (left -= right),
    '*=': (left, right) => (left *= right),
    '/=': (left, right) => (left /= right),
    '%=': (left, right) => (left %= right),
    '<<=': (left, right) => (left <<= right),
    '>>=': (left, right) => (left >>= right),
    '>>>=': (left, right) => (left >>>= right),
    '|=': (left, right) => (left |= right),
    '^=': (left, right) => (left ^= right),
    '&=': (left, right) => (left &= right),
};

class Scope {
    readFromStash;
    addToStash;
    modifyStash;
    consts = {};
    vars = {};
    constructor(readFromStash, addToStash, modifyStash) {
        this.readFromStash = readFromStash;
        this.addToStash = addToStash;
        this.modifyStash = modifyStash;
    }
    exists(name) {
        return name in this.consts || name in this.vars;
    }
    isConst(name) {
        return name in this.consts;
    }
    get(name) {
        const index = this.consts[name] ?? this.vars[name] ?? undefined;
        if (index === undefined)
            throw new Error(`Variable ${name} does not exist`);
        return this.readFromStash(index);
    }
    defineConst(name, value) {
        if (this.exists(name))
            throw new Error(`Variable ${name} already exists`);
        this.consts[name] = this.addToStash(value);
    }
    set(name, value) {
        if (this.isConst(name))
            throw new Error(`Variable ${name} is a constant`);
        if (!this.exists(name)) {
            this.vars[name] = this.addToStash(value);
            return;
        }
        const index = this.vars[name];
        this.modifyStash(index, value);
    }
    copy() {
        const scope = new Scope(this.readFromStash, this.addToStash, this.modifyStash);
        scope.consts = { ...this.consts };
        scope.vars = { ...this.vars };
        return scope;
    }
}

class Compiler {
    sql;
    supportedMethods;
    resolveFn;
    varStash;
    readFromStash(index) {
        return this.varStash[index];
    }
    addToStash(value) {
        this.varStash.push(value);
        return this.varStash.length - 1;
    }
    modifyStash(index, value) {
        this.varStash[index] = value;
    }
    constructor({ query, resolveFn, supportedMethods = {} }) {
        this.sql = query;
        this.resolveFn = resolveFn;
        this.supportedMethods = supportedMethods;
        this.varStash = [];
    }
    async compile() {
        const fragment = parse(this.sql);
        const localScope = new Scope(this.readFromStash.bind(this), this.addToStash.bind(this), this.modifyStash.bind(this));
        const compiledSql = (await this.parseBaseNode(fragment, localScope))
            .replace(/ +/g, ' ') // Remove extra spaces
            .trim(); // Remove leading and trailing spaces
        return compiledSql;
    }
    parseBaseNode = async (node, localScope) => {
        if (!node)
            return '';
        switch (node.type) {
            case 'Fragment':
                return this.parseBaseNodeChildren(node.children, localScope);
            case 'Comment':
                return node.raw;
            case 'Text':
                return node.raw;
            case 'MustacheTag':
                return await this.parseLogicNode(node.expression, localScope);
            case 'ConstTag':
                // Only allow equal expressions to define constants
                const expression = node.expression;
                if (expression.type !== 'AssignmentExpression' ||
                    expression.operator !== '=' ||
                    expression.left.type !== 'Identifier') {
                    this.baseNodeError(errors.invalidConstantDefinition, node);
                }
                const constName = expression.left.name;
                const constValue = await this.resolveLogicNodeExpression(expression.right, localScope);
                if (localScope.exists(constName)) {
                    this.baseNodeError(errors.variableAlreadyDeclared(constName), node);
                }
                localScope.defineConst(constName, constValue);
                return '';
            case 'IfBlock':
                return (await this.resolveLogicNodeExpression(node.expression, localScope))
                    ? this.parseBaseNodeChildren(node.children, localScope)
                    : await this.parseBaseNode(node.else, localScope);
            case 'ElseBlock':
                return this.parseBaseNodeChildren(node.children, localScope);
            case 'EachBlock':
                const iterableElement = await this.resolveLogicNodeExpression(node.expression, localScope);
                if (!Array.isArray(iterableElement) || !iterableElement.length) {
                    return await this.parseBaseNode(node.else, localScope);
                }
                const contextVar = node.context.name;
                const indexVar = node.index;
                if (localScope.exists(contextVar)) {
                    this.baseNodeError(errors.variableAlreadyDeclared(contextVar), node);
                }
                if (indexVar && localScope.exists(indexVar)) {
                    this.baseNodeError(errors.variableAlreadyDeclared(indexVar), node);
                }
                const parsedChildren = [];
                for (let i = 0; i < iterableElement.length; i++) {
                    const element = iterableElement[i];
                    if (indexVar)
                        localScope.set(indexVar, i);
                    localScope.set(contextVar, element);
                    parsedChildren.push(await this.parseBaseNodeChildren(node.children, localScope));
                }
                return parsedChildren.join('') || '';
            default:
                throw this.baseNodeError(errors.unsupportedBaseNodeType(node.type), node);
        }
    };
    parseLogicNode = async (node, localScope) => {
        if (node.type === 'AssignmentExpression') {
            await this.resolveLogicNodeExpression(node, localScope);
            return '';
        }
        if (node.type === 'CallExpression') {
            return await this.handleFunction(node, true, localScope);
        }
        const value = await this.resolveLogicNodeExpression(node, localScope);
        const resolvedValue = await this.resolveFn(value);
        return resolvedValue;
    };
    resolveLogicNodeExpression = async (node, localScope) => {
        switch (node.type) {
            case 'Literal':
                return node.value;
            case 'Identifier':
                if (!localScope.exists(node.name)) {
                    this.expressionError(errors.variableNotDeclared(node.name), node);
                }
                return localScope.get(node.name);
            case 'ObjectExpression':
                const resolvedObject = {};
                for (const prop of node.properties) {
                    if (prop.type !== 'Property') {
                        throw this.expressionError(errors.invalidObjectKey, node);
                    }
                    const key = prop.key;
                    const value = await this.resolveLogicNodeExpression(prop.value, localScope);
                    resolvedObject[key.name] = value;
                }
                return resolvedObject;
            case 'ArrayExpression':
                return await Promise.all(node.elements.map((element) => element
                    ? this.resolveLogicNodeExpression(element, localScope)
                    : null));
            case 'SequenceExpression':
                return await Promise.all(node.expressions.map((expression) => this.resolveLogicNodeExpression(expression, localScope)));
            case 'BinaryExpression':
            case 'LogicalExpression':
                const binaryOperator = node.operator;
                if (!BINARY_OPERATOR_METHODS.hasOwnProperty(binaryOperator)) {
                    this.expressionError(errors.unsupportedOperator(binaryOperator), node);
                }
                const leftOperand = await this.resolveLogicNodeExpression(node.left, localScope);
                const rightOperand = await this.resolveLogicNodeExpression(node.right, localScope);
                return BINARY_OPERATOR_METHODS[binaryOperator]?.(leftOperand, rightOperand);
            case 'UnaryExpression':
                const unaryOperator = node.operator;
                if (!UNARY_OPERATOR_METHODS.hasOwnProperty(unaryOperator)) {
                    this.expressionError(errors.unsupportedOperator(unaryOperator), node);
                }
                const unaryArgument = await this.resolveLogicNodeExpression(node.argument, localScope);
                const unaryPrefix = node.prefix;
                return UNARY_OPERATOR_METHODS[unaryOperator]?.(unaryArgument, unaryPrefix);
            case 'AssignmentExpression':
                const assignedVariableName = node.left.name;
                let assignedValue = await this.resolveLogicNodeExpression(node.right, localScope);
                const assignmentOperator = node.operator;
                if (assignmentOperator != '=') {
                    if (!ASSIGNMENT_OPERATOR_METHODS.hasOwnProperty(assignmentOperator)) {
                        this.expressionError(errors.unsupportedOperator(assignmentOperator), node);
                    }
                    if (!localScope.exists(assignedVariableName)) {
                        this.expressionError(errors.variableNotDeclared(assignedVariableName), node);
                    }
                    assignedValue = ASSIGNMENT_OPERATOR_METHODS[assignmentOperator]?.(localScope.get(assignedVariableName), assignedValue);
                }
                if (localScope.isConst(assignedVariableName)) {
                    this.expressionError(errors.constantReassignment, node);
                }
                localScope.set(assignedVariableName, assignedValue);
                return assignedValue;
            case 'UpdateExpression':
                const updateOperator = node.operator;
                if (!['++', '--'].includes(updateOperator)) {
                    this.expressionError(errors.unsupportedOperator(updateOperator), node);
                }
                const updatedVariableName = node.argument.name;
                if (!localScope.exists(updatedVariableName)) {
                    this.expressionError(errors.variableNotDeclared(updatedVariableName), node);
                }
                if (localScope.isConst(updatedVariableName)) {
                    this.expressionError(errors.constantReassignment, node);
                }
                const originalValue = localScope.get(updatedVariableName);
                const updatedValue = updateOperator === '++'
                    ? originalValue + 1
                    : originalValue - 1;
                localScope.set(updatedVariableName, updatedValue);
                return node.prefix ? updatedValue : originalValue;
            case 'MemberExpression':
                const object = (await this.resolveLogicNodeExpression(node.object, localScope));
                const property = node.computed
                    ? await this.resolveLogicNodeExpression(node.property, localScope)
                    : node.property.name;
                return MEMBER_EXPRESSION_METHOD(object, property);
            case 'ConditionalExpression':
                const test = await this.resolveLogicNodeExpression(node.test, localScope);
                const consequent = await this.resolveLogicNodeExpression(node.consequent, localScope);
                const alternate = await this.resolveLogicNodeExpression(node.alternate, localScope);
                return test ? consequent : alternate;
            case 'CallExpression':
                return await this.handleFunction(node, false, localScope);
            case 'NewExpression':
                throw this.expressionError(errors.unsupportedOperator('new'), node);
            default:
                throw this.expressionError(errors.unsupportedExpressionType(node.type), node);
        }
    };
    parseBaseNodeChildren = async (children, localScope) => {
        const parsedChildren = [];
        const childrenScope = localScope.copy();
        for (const child of children || []) {
            const parsedChild = await this.parseBaseNode(child, childrenScope);
            parsedChildren.push(parsedChild);
        }
        return parsedChildren.join('') || '';
    };
    baseNodeError({ code, message }, node) {
        error(message, {
            name: 'CompileError',
            code,
            source: this.sql || '',
            start: node.start || 0,
            end: node.end || undefined,
        });
    }
    expressionError({ code, message }, node) {
        const source = (node.loc?.source ?? this.sql).split('\n');
        const start = source
            .slice(0, node.loc?.start.line - 1)
            .reduce((acc, line) => acc + line.length + 1, 0) +
            node.loc?.start.column;
        const end = source
            .slice(0, node.loc?.end.line - 1)
            .reduce((acc, line) => acc + line.length + 1, 0) + node.loc?.end.column;
        error(message, {
            name: 'CompileError',
            code,
            source: this.sql || '',
            start,
            end,
        });
    }
    handleFunction = async (node, interpolation, localScope) => {
        const methodName = node.callee.name;
        if (!this.supportedMethods.hasOwnProperty(methodName)) {
            this.expressionError(errors.unknownFunction(methodName), node);
        }
        const method = this.supportedMethods[methodName];
        const args = [];
        for (const arg of node.arguments) {
            args.push(await this.resolveLogicNodeExpression(arg, localScope));
        }
        try {
            const returnedValue = (await method(interpolation, ...args));
            if (interpolation && typeof returnedValue !== 'string') {
                this.expressionError(errors.invalidFunctionResultInterpolation, node);
            }
            return returnedValue;
        }
        catch (error) {
            if (error instanceof CompileError)
                throw error;
            this.expressionError(errors.functionCallError(methodName, error.message), node);
        }
    };
}

function compile({ query, supportedMethods, resolveFn }) {
    return new Compiler({
        query,
        supportedMethods,
        resolveFn
    }).compile();
}

export { CompileError, compile as default };
//# sourceMappingURL=index.js.map
