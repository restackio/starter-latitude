{"version":3,"file":"index.js","sources":["../src/error/error.ts","../src/error/errors.ts","../src/parser/utils/full_char_code_at.ts","../src/utils/names.ts","../src/parser/state/dash_comment.ts","../src/parser/state/multi_line_comment.ts","../src/parser/utils/acorn.ts","../src/parser/read/expression.ts","../src/parser/utils/bracket.ts","../src/parser/read/context.ts","../src/parser/state/mustache.ts","../src/parser/state/text.ts","../src/parser/state/fragment.ts","../src/parser/index.ts","../src/compiler/operators.ts","../src/compiler/scope.ts","../src/compiler/index.ts","../src/index.ts"],"sourcesContent":["import { locate } from 'locate-character'\n\nexport interface Position {\n  line: number\n  column: number\n}\n\ntype CompileErrorProps = {\n  name: string\n  code: string\n  source: string\n  start: number\n  end?: number\n}\n\nexport default class CompileError extends Error {\n  code?: string\n  start?: Position\n  end?: Position\n  pos?: number\n  frame?: string\n\n  toString() {\n    if (!this.start) return this.message\n    return `${this.message} (${this.start.line}:${this.start.column})\\n${this.frame}`\n  }\n}\n\nfunction tabsToSpaces(str: string) {\n  return str.replace(/^\\t+/, (match) => match.split('\\t').join('  '))\n}\n\nfunction getCodeFrame(\n  source: string,\n  line: number,\n  startColumn: number,\n  endColumn: number | undefined,\n): string {\n  const lines = source.split('\\n')\n  const frameStart = Math.max(0, line - 2)\n  const frameEnd = Math.min(line + 3, lines.length)\n  const digits = String(frameEnd + 1).length\n  return lines\n    .slice(frameStart, frameEnd)\n    .map((str, i) => {\n      const isErrorLine = frameStart + i === line\n      const lineNum = String(i + frameStart + 1).padStart(digits, ' ')\n      if (isErrorLine) {\n        const indicator =\n          ' '.repeat(\n            digits + 2 + tabsToSpaces(str.slice(0, startColumn)).length,\n          ) +\n          '^' +\n          '~'.repeat(endColumn ? Math.max(0, endColumn - startColumn - 1) : 0)\n        return `${lineNum}: ${tabsToSpaces(str)}\\n\\n${indicator}`\n      }\n      return `${lineNum}: ${tabsToSpaces(str)}`\n    })\n    .join('\\n')\n}\n\nexport function error(message: string, props: CompileErrorProps): never {\n  const error = new CompileError(message)\n  error.name = props.name\n  const start = locate(props.source, props.start, { offsetLine: 1 })\n  const end = locate(props.source, props.end || props.start, { offsetLine: 1 })\n  error.code = props.code\n  error.start = start\n  error.end = end\n  error.pos = props.start\n  error.frame = getCodeFrame(\n    props.source,\n    (start?.line ?? 1) - 1,\n    start?.column ?? 0,\n    end?.column,\n  )\n  throw error\n}\n","export default {\n  unexpectedEof: {\n    code: 'unexpected-eof',\n    message: 'Unexpected end of input',\n  },\n  unexpectedEofToken: (token: string) => ({\n    code: 'unexpected-eof',\n    message: `Unexpected '${token}'`,\n  }),\n  unexpectedToken: (token: string) => ({\n    code: 'unexpected-token',\n    message: `Expected '${token}'`,\n  }),\n  unexpectedBlockClose: {\n    code: 'unexpected-block-close',\n    message: 'Unexpected block closing tag',\n  },\n  invalidElseif: {\n    code: 'invalid-elseif',\n    message: \"'elseif' should be 'else if'\",\n  },\n  invalidElseifPlacementUnclosedBlock: (block: string) => ({\n    code: 'invalid-elseif-placement',\n    message: `Expected to close ${block} before seeing {:else if ...} block`,\n  }),\n  invalidElseifPlacementOutsideIf: {\n    code: 'invalid-elseif-placement',\n    message: 'Cannot have an {:else if ...} block outside an {#if ...} block',\n  },\n  invalidElsePlacementUnclosedBlock: (block: string) => ({\n    code: 'invalid-else-placement',\n    message: `Expected to close ${block} before seeing {:else} block`,\n  }),\n  invalidElsePlacementOutsideIf: {\n    code: 'invalid-else-placement',\n    message:\n      'Cannot have an {:else} block outside an {#if ...} or {#each ...} block',\n  },\n  expectedBlockType: {\n    code: 'expected-block-type',\n    message: 'Expected if or each',\n  },\n  unexpectedTokenDestructure: {\n    code: 'unexpected-token',\n    message: 'Expected identifier or destructure pattern',\n  },\n  expectedName: {\n    code: 'expected-name',\n    message: 'Expected name',\n  },\n  unexpectedMustacheCloseTag: {\n    code: 'unexpected-mustache-close-tag',\n    message: 'Unexpected closing tag without matching opening tag',\n  },\n  unexpectedEndOfComment: {\n    code: 'unexpected-end-of-comment',\n    message: 'Unexpected end of comment',\n  },\n\n  // Compiler errors:\n  queryNotFound: (name: string) => ({\n    code: 'query-not-found',\n    message: `Query '${name}' not found`,\n  }),\n  unsupportedBaseNodeType: (type: string) => ({\n    code: 'unsupported-base-node-type',\n    message: `Unsupported base node type: ${type}`,\n  }),\n  unsupportedExpressionType: (type: string) => ({\n    code: 'unsupported-expression-type',\n    message: `Unsupported expression type: ${type}`,\n  }),\n  invalidConstantDefinition: {\n    code: 'invalid-constant-definition',\n    message: 'Constant definitions must assign a value to a variable',\n  },\n  variableAlreadyDeclared: (name: string) => ({\n    code: 'variable-already-declared',\n    message: `Variable '${name}' is already declared`,\n  }),\n  variableNotDeclared: (name: string) => ({\n    code: 'variable-not-declared',\n    message: `Variable '${name}' is not declared`,\n  }),\n  invalidObjectKey: {\n    code: 'invalid-object-key',\n    message: 'Invalid object key',\n  },\n  unsupportedOperator: (operator: string) => ({\n    code: 'unsupported-operator',\n    message: `Unsupported operator: ${operator}`,\n  }),\n  constantReassignment: {\n    code: 'constant-reassignment',\n    message: 'Cannot reassign a constant',\n  },\n  unknownFunction: (name: string) => ({\n    code: 'unknown-function',\n    message: `Unknown function: ${name}`,\n  }),\n  functionCallError: (name: string, message: string) => ({\n    code: 'function-call-error',\n    message: `Error calling function '${name}': ${message}`,\n  }),\n  invalidFunctionResultInterpolation: {\n    code: 'invalid-function-result-interpolation',\n    message: 'Functions called for interpolation must return a string',\n  },\n}\n","// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js\n\nexport default function fullCharCodeAt(str: string, i: number): number {\n  const code = str.charCodeAt(i);\n  if (code <= 0xd7ff || code >= 0xe000) return code;\n\n  const next = str.charCodeAt(i + 1);\n  return (code << 10) + next - 0x35fdc00;\n}","export const reserved = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n])\n","import { Parser } from \"..\";\n\nexport function dashComment(parser: Parser) {\n  const start = parser.index;\n\n  let data = '';\n\n  while (parser.index < parser.template.length) {\n    if (parser.matchRegex(/\\n/)) {\n      break;\n    }\n    data += parser.template[parser.index++];\n  }\n\n  const node = {\n    start,\n    end: parser.index,\n    type: 'Comment',\n    raw: data,\n    data: data.substring(2)\n  };\n\n  parser.current().children!.push(node);\n}","import { Parser } from \"..\";\nimport PARSER_ERRORS from '../../error/errors';\n\nexport function multiLineComment(parser: Parser) {\n  if (parser.match('*/')) {\n    parser.error(PARSER_ERRORS.unexpectedEndOfComment)\n  }\n\n  const start = parser.index;\n\n  while (parser.index < parser.template.length) {\n    if (parser.matchRegex(/\\*\\//)) {\n      parser.index += 2;\n      break;\n    }\n    parser.index++\n  }\n\n  const data = parser.template.substring(start, parser.index);\n\n  const node = {\n    start,\n    end: parser.index + 1,\n    type: 'Comment',\n    raw: data,\n    data: data.substring(2, data.length - 2)\n  };\n\n  parser.current().children!.push(node)\n}","import * as code_red from 'code-red';\n\nexport const parse = (source: string) =>\n  code_red.parse(source, {\n    sourceType: 'module',\n    ecmaVersion: 13,\n    locations: true\n  });\n\nexport const parseExpressionAt = (source: string, index: number) =>\n  code_red.parseExpressionAt(source, index, {\n    sourceType: 'module',\n    ecmaVersion: 13,\n    locations: true\n  });\n","import { Parser } from \"..\";\nimport { parseExpressionAt } from \"../utils/acorn\"\nimport PARSER_ERRORS from \"../../error/errors\"\nimport CompileError from \"../../error/error\";\n\nexport default function readExpression(parser: Parser) {\n  try {\n    const node = parseExpressionAt(parser.template, parser.index);\n\n    let numParenthesis = 0;\n\n    for (let i = parser.index; i < node.start; i += 1) {\n      if (parser.template[i] === '(') numParenthesis += 1;\n    }\n\n    let index = node.end;\n    while (numParenthesis > 0) {\n      const char = parser.template[index]\n\n      if (char === ')') {\n        numParenthesis -= 1;\n      } else if (!/\\s/.test(char!)) {\n        parser.error(PARSER_ERRORS.unexpectedToken(')'), index);\n      }\n\n      index += 1;\n    }\n\n    parser.index = index;\n\n    return node;\n  } catch (err) {\n    parser.acornError(err as CompileError);\n  }\n}","const SQUARE_BRACKET_OPEN = '['.charCodeAt(0);\nconst SQUARE_BRACKET_CLOSE = ']'.charCodeAt(0);\nconst CURLY_BRACKET_OPEN = '{'.charCodeAt(0);\nconst CURLY_BRACKET_CLOSE = '}'.charCodeAt(0);\n\nexport function isBracketOpen(code: number) {\n  return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;\n}\n\nexport function isBracketClose(code: number) {\n  return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;\n}\n\nexport function isBracketPair(open: number, close: number) {\n  return (\n    (open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE) ||\n    (open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE)\n  );\n}\n\nexport function getBracketClose(open: number): number|undefined {\n  if (open === SQUARE_BRACKET_OPEN) {\n    return SQUARE_BRACKET_CLOSE;\n  }\n  if (open === CURLY_BRACKET_OPEN) {\n    return CURLY_BRACKET_CLOSE;\n  }\n}\n","// @ts-expect-error - no types for this package\nimport { isIdentifierStart } from 'acorn'\nimport fullCharCodeAt from '../utils/full_char_code_at';\nimport {\n  isBracketOpen,\n  isBracketClose,\n  isBracketPair,\n  getBracketClose\n} from '../utils/bracket';\nimport { parseExpressionAt } from '../utils/acorn';\nimport PARSER_ERRORS from '../../error/errors';\nimport { Parser } from '..';\nimport type CompileError from '../../error/error';\nimport { Pattern } from 'estree';\n\nexport default function readContext(parser: Parser): Pattern & { start: number; end: number } {\n  const start = parser.index;\n  let i = parser.index;\n\n  const code = fullCharCodeAt(parser.template, i);\n  if (isIdentifierStart(code, true)) {\n    return {\n      type: 'Identifier',\n      name: parser.readIdentifier()!,\n      start,\n      end: parser.index\n    };\n  }\n\n  if (!isBracketOpen(code)) {\n    parser.error(PARSER_ERRORS.unexpectedTokenDestructure);\n  }\n\n  const bracketStack: number[] = [code];\n  i += code <= 0xffff ? 1 : 2;\n\n  while (i < parser.template.length) {\n    const code = fullCharCodeAt(parser.template, i);\n    if (isBracketOpen(code)) {\n      bracketStack.push(code);\n    } else if (isBracketClose(code)) {\n      if (!isBracketPair(bracketStack[bracketStack.length - 1]!, code)) {\n        parser.error(\n          PARSER_ERRORS.unexpectedToken(\n            String.fromCharCode(getBracketClose(bracketStack[bracketStack.length - 1]!) ?? 0)\n          )\n        );\n      }\n      bracketStack.pop();\n      if (bracketStack.length === 0) {\n        i += code <= 0xffff ? 1 : 2;\n        break;\n      }\n    }\n    i += code <= 0xffff ? 1 : 2;\n  }\n\n  parser.index = i;\n\n  const patternString = parser.template.slice(start, i);\n  try {\n    // the length of the `space_with_newline` has to be start - 1\n    // because we added a `(` in front of the pattern_string,\n    // which shifted the entire string to right by 1\n    // so we offset it by removing 1 character in the `space_with_newline`\n    // to achieve that, we remove the 1st space encountered,\n    // so it will not affect the `column` of the node\n    let spaceWithNewLine = parser.template\n      .slice(0, start)\n      .replace(/[^\\n]/g, ' ');\n    const firstSpace = spaceWithNewLine.indexOf(' ');\n    spaceWithNewLine =\n      spaceWithNewLine.slice(0, firstSpace) + spaceWithNewLine.slice(firstSpace + 1);\n\n    return parseExpressionAt(`${spaceWithNewLine}(${patternString} = 1)`, start - 1).left;\n  } catch (error) {\n    parser.acornError(error as CompileError);\n  }\n\n  return {\n    type: 'Identifier',\n    name: '',\n    start: parser.index,\n    end: parser.index\n  };\n}\n","import { type Parser } from \"..\";\nimport PARSER_ERRORS from '../../error/errors';\nimport { type TemplateNode } from \"../interfaces\";\nimport readExpression from \"../read/expression\";\nimport readContext from \"../read/context\";\n\nexport function mustache(parser: Parser) {\n  if (parser.match('}')) {\n    parser.error(PARSER_ERRORS.unexpectedMustacheCloseTag);\n  }\n  const start = parser.index;\n  parser.index += 1;\n  parser.allowWhitespace();\n  // {/if}, {/each}, {/await} or {/key}\n  if (parser.eat('/')) {\n    let block = parser.current();\n    let expected: string\n    if (\n      block.type === 'ElseBlock'\n    ) {\n      block.end = start;\n      parser.stack.pop();\n      block = parser.current();\n      expected = 'else';\n    }\n    if (block.type === 'IfBlock') {\n      expected = 'if';\n    } else if (block.type === 'EachBlock') {\n      expected = 'each';\n    } else {\n      parser.error(PARSER_ERRORS.unexpectedBlockClose);\n    }\n    parser.eat(expected!, true);\n    parser.allowWhitespace();\n    parser.eat('}', true);\n    while (block.elseif) {\n      block.end = parser.index;\n      parser.stack.pop();\n      block = parser.current();\n      if (block.else) {\n        block.else.end = start;\n      }\n    }\n    // strip leading/trailing whitespace as necessary\n    const charBefore = parser.template[block.start! - 1];\n    const charAfter = parser.template[parser.index];\n    const trimBefore = !charBefore || /\\s/.test(charBefore);\n    const trimAfter = !charAfter || /\\s/.test(charAfter);\n    trimWhitespace(block, trimBefore, trimAfter);\n    block.end = parser.index;\n    parser.stack.pop();\n  } else if (parser.eat(':else')) {\n    if (parser.eat('if')) {\n      parser.error(PARSER_ERRORS.invalidElseif);\n    }\n    parser.allowWhitespace();\n    // :else if\n    if (parser.eat('if')) {\n      const block = parser.current();\n      if (block.type !== 'IfBlock') {\n        parser.error(\n          parser.stack.some((block) => block.type === 'IfBlock')\n            ? PARSER_ERRORS.invalidElseifPlacementUnclosedBlock(toString(block))\n            : PARSER_ERRORS.invalidElseifPlacementOutsideIf\n        );\n      }\n      parser.requireWhitespace();\n      const expression = readExpression(parser);\n      parser.allowWhitespace();\n      parser.eat('}', true);\n      block.else = {\n        start: parser.index,\n        end: null,\n        type: 'ElseBlock',\n        children: [\n          {\n            start: parser.index,\n            end: null,\n            type: 'IfBlock',\n            elseif: true,\n            expression,\n            children: []\n          }\n        ]\n      };\n      parser.stack.push(block.else.children[0]);\n    } else {\n      // :else\n      const block = parser.current();\n      if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {\n        parser.error(\n          parser.stack.some((block) => block.type === 'IfBlock' || block.type === 'EachBlock')\n            ? PARSER_ERRORS.invalidElsePlacementUnclosedBlock(toString(block))\n            : PARSER_ERRORS.invalidElsePlacementOutsideIf\n        );\n      }\n      parser.allowWhitespace();\n      parser.eat('}', true);\n      block.else = {\n        start: parser.index,\n        end: null,\n        type: 'ElseBlock',\n        children: []\n      };\n      parser.stack.push(block.else);\n    }\n  } else if (parser.eat('#')) {\n    // {#if foo}, {#each foo} or {#await foo}\n    const isIf = parser.eat('if')\n    const isEach = parser.eat('each')\n    if (!isIf && !isEach) {\n      parser.error(PARSER_ERRORS.expectedBlockType);\n    }\n    const type = isIf ? 'IfBlock' : 'EachBlock'\n    parser.requireWhitespace();\n    const expression = readExpression(parser);\n    const block: TemplateNode = {\n      start,\n      end: start,\n      type,\n      expression,\n      children: []\n    }\n    parser.allowWhitespace();\n    // {#each} blocks must declare a context – {#each list as item}\n    if (type === 'EachBlock') {\n      parser.eat('as', true);\n      parser.requireWhitespace();\n      block['context'] = readContext(parser);\n      parser.allowWhitespace();\n      if (parser.eat(',')) {\n        parser.allowWhitespace();\n        block.index = parser.readIdentifier();\n        if (!block.index) parser.error(PARSER_ERRORS.expectedName);\n        parser.allowWhitespace();\n      }\n      if (parser.eat('(')) {\n        parser.allowWhitespace();\n        block.key = readExpression(parser);\n        parser.allowWhitespace();\n        parser.eat(')', true);\n        parser.allowWhitespace();\n      }\n    }\n    parser.eat('}', true);\n    parser.current().children!.push(block);\n    parser.stack.push(block);  \n  } else if (parser.eat('@const')) {\n    // {@const a = b}\n    parser.requireWhitespace();\n    const expression = readExpression(parser);\n    if (!(expression.type === 'AssignmentExpression' && expression.operator === '=')) {\n      parser.error(\n        {\n          code: 'invalid-const-args',\n          message: '{@const ...} must be an assignment.'\n        },\n        start\n      );\n    }\n    parser.allowWhitespace();\n    parser.eat('}', true);\n    parser.current().children!.push({\n      start,\n      end: parser.index,\n      type: 'ConstTag',\n      expression\n    });\n  } else {\n    const expression = readExpression(parser);\n    parser.allowWhitespace();\n    parser.eat('}', true);\n    parser.current().children!.push({\n      start,\n      end: parser.index,\n      type: 'MustacheTag',\n      expression\n    });\n  }\n}\n\nfunction trimWhitespace(block: TemplateNode, trimBefore: boolean = false, trimAfter: boolean = false) {\n  if (!block.children || block.children.length === 0) return; // AwaitBlock\n  const firstChild = block.children[0]!;\n  const lastChild = block.children[block.children.length - 1]!;\n  if (firstChild.type === 'Text' && trimBefore) {\n    firstChild.data = firstChild.data.replace(/^[ \\t\\r\\n]*/, '');\n    if (!firstChild.data) block.children.shift();\n  }\n  if (lastChild.type === 'Text' && trimAfter) {\n    lastChild.data = lastChild.data.replace(/[ \\t\\r\\n]*$/, '')\n    if (!lastChild.data) block.children.pop();\n  }\n  if (block.else) {\n    trimWhitespace(block.else, trimBefore, trimAfter);\n  }\n  if (firstChild.elseif) {\n    trimWhitespace(firstChild, trimBefore, trimAfter);\n  }\n}\n\nfunction toString(node: TemplateNode) {\n  switch (node.type) {\n    case 'IfBlock':\n      return '{#if} block'\n    case 'ElseBlock':\n      return '{:else} block'\n    case 'EachBlock':\n      return '{#each} block'\n    case 'ConstTag':\n      return '{@const} tag'\n    default:\n      return node.type;\n  }\n}","import { type Parser } from \"..\";\n\nconst STRING_DELIMITERS_REGEX = /['\"`]/;\nfunction textInString(parser: Parser, char: string): string {\n  let data = '';\n\n  while (parser.index < parser.template.length) {\n    if (parser.match(char) && !parser.match(char.repeat(2)) && !data.match(/(?<!\\\\)(\\\\\\\\)*\\\\/)) {\n      break;\n    }\n    data += parser.template[parser.index++];\n  }\n\n  parser.index++\n  return char + data + char;\n}\n\nconst ENDS_WITH_ESCAPE_REGEX = /(?<!\\\\)(\\\\\\\\)*\\\\$/;\nconst RESERVED_DELIMITERS = ['{', '}', '--', '/*', '*/'];\n\nexport function text(parser: Parser) {\n  const start = parser.index;\n  let data = '';\n\n  while (parser.index < parser.template.length) {\n    const isEscaping = ENDS_WITH_ESCAPE_REGEX.test(data);\n    if (isEscaping) data = data.slice(0, -1); // Remove the escape character\n\n    if (!isEscaping && RESERVED_DELIMITERS.some(sample => parser.match(sample))) {\n      break\n    }\n    if (!isEscaping && parser.matchRegex(STRING_DELIMITERS_REGEX)) {\n      data += textInString(parser, parser.template[parser.index++]!)\n      continue;\n    }\n    data += parser.template[parser.index++]\n  }\n\n  const node = {\n    start,\n    end: parser.index,\n    type: 'Text',\n    raw: data,\n    data: data.replace(/(?<!\\\\)\\\\{/g, '{').replace(/(?<!\\\\)\\\\}/g, '}')\n  };\n\n  parser.current().children!.push(node);\n}","import { Parser } from \"..\";\nimport { dashComment } from \"./dash_comment\";\nimport { multiLineComment } from \"./multi_line_comment\";\nimport { mustache } from \"./mustache\";\nimport { text } from \"./text\";\n\nexport default function fragment(parser: Parser): (parser: Parser) => void {\n  if (parser.match('{') || parser.match('}')) {\n    return mustache;\n  }\n  if (parser.match('/*') || parser.match('*/')) {\n    return multiLineComment\n  }\n  if (parser.match('--')) {\n    return dashComment\n  }\n\n  return text\n}","import type CompileError from '../error/error'\nimport { error } from '../error/error'\nimport { type Fragment, type TemplateNode } from './interfaces'\nimport PARSER_ERRORS from '../error/errors'\nimport fullCharCodeAt from './utils/full_char_code_at'\nimport { reserved } from '../utils/names'\n// @ts-expect-error - no types\nimport { isIdentifierStart, isIdentifierChar } from 'acorn'\nimport fragment from './state/fragment'\n\nexport default function parse(template: string) {\n  return new Parser(template).parse()\n}\n\ntype ParserState = (parser: Parser) => void | ParserState\n\nexport class Parser {\n  index: number = 0\n  stack: TemplateNode[] = []\n\n  constructor(public template: string) {}\n\n  parse(): Fragment {\n    const template: Fragment = {\n      start: 0,\n      end: this.template.length,\n      type: 'Fragment',\n      children: [],\n    }\n    this.stack.push(template)\n\n    let state: ParserState = fragment\n    while (this.index < this.template.length) {\n      state = state(this) || fragment\n    }\n    if (this.stack.length > 1) {\n      const current = this.current()\n      this.error(\n        {\n          code: `unclosed-block`,\n          message: `Block was left open`,\n        },\n        current.start!,\n      )\n    }\n    if (state !== fragment) {\n      this.error({\n        code: `unexpected-eof`,\n        message: `Unexpected end of input`,\n      })\n    }\n    if (template.children.length) {\n      let start = template.children[0]!.start!\n      while (/\\s/.test(template[start])) start += 1\n      let end = template.children[template.children.length - 1]!.end!\n      while (/\\s/.test(template[end - 1])) end -= 1\n      template.start = start\n      template.end = end\n    } else {\n      template.start = template.end = null\n    }\n\n    return template\n  }\n\n  current(): TemplateNode {\n    return this.stack[this.stack.length - 1]!\n  }\n\n  match(str: string) {\n    return this.template.slice(this.index, this.index + str.length) === str\n  }\n\n  allowWhitespace() {\n    while (\n      this.index < this.template.length &&\n      /\\s/.test(this.template[this.index] || '')\n    ) {\n      this.index++\n    }\n  }\n\n  requireWhitespace() {\n    if (!/\\s/.test(this.template[this.index]!)) {\n      this.error({\n        code: 'missing-whitespace',\n        message: 'Expected whitespace',\n      })\n    }\n    this.allowWhitespace()\n  }\n\n  eat(\n    str: string,\n    required: boolean = false,\n    error?: { code: string; message: string },\n  ) {\n    if (this.match(str)) {\n      this.index += str.length\n      return true\n    }\n    if (required) {\n      this.error(\n        error ||\n          (this.index === this.template.length\n            ? PARSER_ERRORS.unexpectedEofToken(str)\n            : PARSER_ERRORS.unexpectedToken(str)),\n      )\n    }\n    return false\n  }\n\n  error(\n    { code, message }: { code: string; message: string },\n    index = this.index,\n  ) {\n    error(message, {\n      name: 'ParseError',\n      code,\n      source: this.template,\n      start: index - 1,\n    })\n  }\n\n  acornError(err: CompileError) {\n    this.error(\n      {\n        code: 'parse-error',\n        message: err.message.replace(/ \\(\\d+:\\d+\\)$/, ''),\n      },\n      err.pos,\n    )\n  }\n\n  matchRegex(pattern: RegExp) {\n    const match = pattern.exec(this.template.slice(this.index))\n    if (!match || match.index !== 0) return null\n    return match[0]\n  }\n\n  read(pattern: RegExp) {\n    const result = this.matchRegex(pattern)\n    if (result) this.index += result.length\n    return result\n  }\n\n  readIdentifier(allowReserved: boolean = false) {\n    const start = this.index\n    let i = this.index\n    const code = fullCharCodeAt(this.template, i)\n    if (!isIdentifierStart(code, true)) return null\n    i += code <= 0xffff ? 1 : 2\n    while (i < this.template.length) {\n      const code = fullCharCodeAt(this.template, i)\n      if (!isIdentifierChar(code, true)) break\n      i += code <= 0xffff ? 1 : 2\n    }\n    const identifier = this.template.slice(this.index, (this.index = i))\n    if (!allowReserved && reserved.has(identifier)) {\n      this.error(\n        {\n          code: 'unexpected-reserved-word',\n          message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`,\n        },\n        start,\n      )\n    }\n    return identifier\n  }\n}\n","// https://github.com/estree/estree/blob/master/es5.md#binary-operations\nexport const BINARY_OPERATOR_METHODS: {\n  [operator: string]: (left: any, right: any) => unknown\n} = {\n  // BinaryExpression\n  '==': (left, right) => left == right,\n  '!=': (left, right) => left != right,\n  '===': (left, right) => left === right,\n  '!==': (left, right) => left !== right,\n  '<': (left, right) => left < right,\n  '<=': (left, right) => left <= right,\n  '>': (left, right) => left > right,\n  '>=': (left, right) => left >= right,\n  '<<': (left, right) => left << right,\n  '>>': (left, right) => left >> right,\n  '>>>': (left, right) => left >>> right,\n  '+': (left, right) => left + right,\n  '-': (left, right) => left - right,\n  '*': (left, right) => left * right,\n  '/': (left, right) => left / right,\n  '%': (left, right) => left % right,\n  '|': (left, right) => left | right,\n  '^': (left, right) => left ^ right,\n  '&': (left, right) => left & right,\n  in: (left, right) => left in right,\n  instanceof: (left, right) => (left as object) instanceof right,\n\n  // LogicalExpression\n  '||': (left, right) => left || right,\n  '&&': (left, right) => left && right,\n  '??': (left, right) => left ?? right,\n}\n\n// https://github.com/estree/estree/blob/master/es5.md#unary-operations\nexport const UNARY_OPERATOR_METHODS: {\n  [operator: string]: (value: any, prefix: any) => unknown\n} = {\n  // UnaryExpression\n  '-': (value, prefix) => (prefix ? -value : value),\n  '+': (value, prefix) => (prefix ? +value : value),\n  '!': (value, _) => !value,\n  '~': (value, _) => ~value,\n  typeof: (value, _) => typeof value,\n  void: (value, _) => void value,\n}\n\n// https://github.com/estree/estree/blob/master/es5.md#memberexpression\nexport const MEMBER_EXPRESSION_METHOD = (object: any, property: any): unknown =>\n  object[property]\n\n// https://github.com/estree/estree/blob/master/es5.md#assignmentexpression\nexport const ASSIGNMENT_OPERATOR_METHODS: {\n  [operator: string]: (left: any, right: any) => unknown\n} = {\n  '+=': (left, right) => (left += right),\n  '-=': (left, right) => (left -= right),\n  '*=': (left, right) => (left *= right),\n  '/=': (left, right) => (left /= right),\n  '%=': (left, right) => (left %= right),\n  '<<=': (left, right) => (left <<= right),\n  '>>=': (left, right) => (left >>= right),\n  '>>>=': (left, right) => (left >>>= right),\n  '|=': (left, right) => (left |= right),\n  '^=': (left, right) => (left ^= right),\n  '&=': (left, right) => (left &= right),\n}\n","export default class Scope {\n  private consts: Record<string, number> = {}\n  private vars: Record<string, number> = {}\n\n  constructor(\n    private readFromStash: (index: number) => unknown,\n    private addToStash: (value: unknown) => number,\n    private modifyStash: (index: number, value: unknown) => void,\n  ) {}\n\n  exists(name: string): boolean {\n    return name in this.consts || name in this.vars\n  }\n\n  isConst(name: string): boolean {\n    return name in this.consts\n  }\n\n  get(name: string): unknown {\n    const index = this.consts[name] ?? this.vars[name] ?? undefined\n    if (index === undefined) throw new Error(`Variable ${name} does not exist`)\n    return this.readFromStash(index)\n  }\n\n  defineConst(name: string, value: unknown): void {\n    if (this.exists(name)) throw new Error(`Variable ${name} already exists`)\n    this.consts[name] = this.addToStash(value)\n  }\n\n  set(name: string, value: unknown): void {\n    if (this.isConst(name)) throw new Error(`Variable ${name} is a constant`)\n    if (!this.exists(name)) {\n      this.vars[name] = this.addToStash(value)\n      return\n    }\n    const index = this.vars[name]!\n    this.modifyStash(index, value)\n  }\n\n  copy(): Scope {\n    const scope = new Scope(\n      this.readFromStash,\n      this.addToStash,\n      this.modifyStash,\n    )\n    scope.consts = { ...this.consts }\n    scope.vars = { ...this.vars }\n    return scope\n  }\n}\n","import { BaseNode, type TemplateNode } from '../parser/interfaces'\nimport { type Node, type Identifier, type SimpleCallExpression } from 'estree'\nimport parse from '../parser/index'\nimport {\n  ASSIGNMENT_OPERATOR_METHODS,\n  BINARY_OPERATOR_METHODS,\n  MEMBER_EXPRESSION_METHOD,\n  UNARY_OPERATOR_METHODS,\n} from './operators'\nimport CompileError, { error } from '../error/error'\nimport errors from '../error/errors'\nimport Scope from './scope'\n\ntype CompilerAttrs = {\n  query: string\n  resolveFn: ResolveFn\n  supportedMethods?: Record<string, SupportedMethod>\n}\nexport type SupportedMethod = <T extends boolean>(\n  interpolation: T,\n  ...args: unknown[]\n) => Promise<T extends true ? string : unknown>\nexport type ResolveFn = (value: unknown) => Promise<string>\n\nexport class Compiler {\n  private sql: string\n  private supportedMethods: Record<string, SupportedMethod>\n  private resolveFn: ResolveFn\n\n  private varStash: unknown[]\n\n  private readFromStash(index: number): unknown {\n    return this.varStash[index]\n  }\n\n  private addToStash(value: unknown): number {\n    this.varStash.push(value)\n    return this.varStash.length - 1\n  }\n\n  private modifyStash(index: number, value: unknown): void {\n    this.varStash[index] = value\n  }\n\n  constructor({ query, resolveFn, supportedMethods = {} }: CompilerAttrs) {\n    this.sql = query\n    this.resolveFn = resolveFn\n    this.supportedMethods = supportedMethods\n\n    this.varStash = []\n  }\n\n  async compile(): Promise<string> {\n    const fragment = parse(this.sql)\n    const localScope = new Scope(\n      this.readFromStash.bind(this),\n      this.addToStash.bind(this),\n      this.modifyStash.bind(this),\n    )\n    const compiledSql = (await this.parseBaseNode(fragment, localScope))\n      .replace(/ +/g, ' ') // Remove extra spaces\n      .trim() // Remove leading and trailing spaces\n\n    return compiledSql\n  }\n\n  private parseBaseNode = async (\n    node: BaseNode,\n    localScope: Scope,\n  ): Promise<string> => {\n    if (!node) return ''\n\n    switch (node.type) {\n      case 'Fragment':\n        return this.parseBaseNodeChildren(node.children, localScope)\n\n      case 'Comment':\n        return node.raw\n\n      case 'Text':\n        return node.raw\n\n      case 'MustacheTag':\n        return await this.parseLogicNode(node.expression, localScope)\n\n      case 'ConstTag':\n        // Only allow equal expressions to define constants\n        const expression = node.expression\n        if (\n          expression.type !== 'AssignmentExpression' ||\n          expression.operator !== '=' ||\n          expression.left.type !== 'Identifier'\n        ) {\n          this.baseNodeError(errors.invalidConstantDefinition, node)\n        }\n\n        const constName = (expression.left as Identifier).name\n        const constValue = await this.resolveLogicNodeExpression(\n          expression.right,\n          localScope,\n        )\n        if (localScope.exists(constName)) {\n          this.baseNodeError(errors.variableAlreadyDeclared(constName), node)\n        }\n        localScope.defineConst(constName, constValue)\n        return ''\n\n      case 'IfBlock':\n        return (await this.resolveLogicNodeExpression(\n          node.expression,\n          localScope,\n        ))\n          ? this.parseBaseNodeChildren(node.children, localScope)\n          : await this.parseBaseNode(node.else, localScope)\n\n      case 'ElseBlock':\n        return this.parseBaseNodeChildren(node.children, localScope)\n\n      case 'EachBlock':\n        const iterableElement = await this.resolveLogicNodeExpression(\n          node.expression,\n          localScope,\n        )\n        if (!Array.isArray(iterableElement) || !iterableElement.length) {\n          return await this.parseBaseNode(node.else, localScope)\n        }\n\n        const contextVar = node.context.name\n        const indexVar = node.index\n        if (localScope.exists(contextVar)) {\n          this.baseNodeError(errors.variableAlreadyDeclared(contextVar), node)\n        }\n        if (indexVar && localScope.exists(indexVar)) {\n          this.baseNodeError(errors.variableAlreadyDeclared(indexVar), node)\n        }\n\n        const parsedChildren: string[] = []\n        for (let i = 0; i < iterableElement.length; i++) {\n          const element = iterableElement[i]\n          if (indexVar) localScope.set(indexVar, i)\n          localScope.set(contextVar, element)\n          parsedChildren.push(\n            await this.parseBaseNodeChildren(node.children, localScope),\n          )\n        }\n        return parsedChildren.join('') || ''\n\n      default:\n        throw this.baseNodeError(\n          errors.unsupportedBaseNodeType(node.type),\n          node,\n        )\n    }\n  }\n\n  private parseLogicNode = async (\n    node: Node,\n    localScope: Scope,\n  ): Promise<string> => {\n    if (node.type === 'AssignmentExpression') {\n      await this.resolveLogicNodeExpression(node, localScope)\n      return ''\n    }\n\n    if (node.type === 'CallExpression') {\n      return await this.handleFunction(\n        node as SimpleCallExpression,\n        true,\n        localScope,\n      )\n    }\n\n    const value = await this.resolveLogicNodeExpression(node, localScope)\n    const resolvedValue = await this.resolveFn(value)\n\n    return resolvedValue\n  }\n\n  private resolveLogicNodeExpression = async (\n    node: Node,\n    localScope: Scope,\n  ): Promise<unknown> => {\n    switch (node.type) {\n      case 'Literal':\n        return node.value\n\n      case 'Identifier':\n        if (!localScope.exists(node.name)) {\n          this.expressionError(errors.variableNotDeclared(node.name), node)\n        }\n        return localScope.get(node.name)\n\n      case 'ObjectExpression':\n        const resolvedObject: { [key: string]: any } = {}\n        for (const prop of node.properties) {\n          if (prop.type !== 'Property') {\n            throw this.expressionError(errors.invalidObjectKey, node)\n          }\n          const key = prop.key as Identifier\n          const value = await this.resolveLogicNodeExpression(\n            prop.value,\n            localScope,\n          )\n          resolvedObject[key.name] = value\n        }\n        return resolvedObject\n\n      case 'ArrayExpression':\n        return await Promise.all(\n          node.elements.map((element) =>\n            element\n              ? this.resolveLogicNodeExpression(element, localScope)\n              : null,\n          ),\n        )\n\n      case 'SequenceExpression':\n        return await Promise.all(\n          node.expressions.map((expression) =>\n            this.resolveLogicNodeExpression(expression, localScope),\n          ),\n        )\n\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        const binaryOperator = node.operator\n        if (!BINARY_OPERATOR_METHODS.hasOwnProperty(binaryOperator)) {\n          this.expressionError(errors.unsupportedOperator(binaryOperator), node)\n        }\n        const leftOperand = await this.resolveLogicNodeExpression(\n          node.left,\n          localScope,\n        )\n        const rightOperand = await this.resolveLogicNodeExpression(\n          node.right,\n          localScope,\n        )\n        return BINARY_OPERATOR_METHODS[binaryOperator]?.(\n          leftOperand,\n          rightOperand,\n        )\n\n      case 'UnaryExpression':\n        const unaryOperator = node.operator\n        if (!UNARY_OPERATOR_METHODS.hasOwnProperty(unaryOperator)) {\n          this.expressionError(errors.unsupportedOperator(unaryOperator), node)\n        }\n\n        const unaryArgument = await this.resolveLogicNodeExpression(\n          node.argument,\n          localScope,\n        )\n        const unaryPrefix = node.prefix\n        return UNARY_OPERATOR_METHODS[unaryOperator]?.(\n          unaryArgument,\n          unaryPrefix,\n        )\n\n      case 'AssignmentExpression':\n        const assignedVariableName = (node.left as Identifier).name\n        let assignedValue = await this.resolveLogicNodeExpression(\n          node.right,\n          localScope,\n        )\n        const assignmentOperator = node.operator\n\n        if (assignmentOperator != '=') {\n          if (!ASSIGNMENT_OPERATOR_METHODS.hasOwnProperty(assignmentOperator)) {\n            this.expressionError(\n              errors.unsupportedOperator(assignmentOperator),\n              node,\n            )\n          }\n          if (!localScope.exists(assignedVariableName)) {\n            this.expressionError(\n              errors.variableNotDeclared(assignedVariableName),\n              node,\n            )\n          }\n          assignedValue = ASSIGNMENT_OPERATOR_METHODS[assignmentOperator]?.(\n            localScope.get(assignedVariableName),\n            assignedValue,\n          )\n        }\n        if (localScope.isConst(assignedVariableName)) {\n          this.expressionError(errors.constantReassignment, node)\n        }\n        localScope.set(assignedVariableName, assignedValue)\n        return assignedValue\n\n      case 'UpdateExpression':\n        const updateOperator = node.operator\n        if (!['++', '--'].includes(updateOperator)) {\n          this.expressionError(errors.unsupportedOperator(updateOperator), node)\n        }\n        const updatedVariableName = (node.argument as Identifier).name\n        if (!localScope.exists(updatedVariableName)) {\n          this.expressionError(\n            errors.variableNotDeclared(updatedVariableName),\n            node,\n          )\n        }\n        if (localScope.isConst(updatedVariableName)) {\n          this.expressionError(errors.constantReassignment, node)\n        }\n        const originalValue = localScope.get(updatedVariableName)\n        const updatedValue =\n          updateOperator === '++'\n            ? (originalValue as number) + 1\n            : (originalValue as number) - 1\n        localScope.set(updatedVariableName, updatedValue)\n        return node.prefix ? updatedValue : originalValue\n\n      case 'MemberExpression':\n        const object = (await this.resolveLogicNodeExpression(\n          node.object,\n          localScope,\n        )) as {\n          [key: string]: any\n        }\n        const property = node.computed\n          ? await this.resolveLogicNodeExpression(node.property, localScope)\n          : (node.property as Identifier).name\n        return MEMBER_EXPRESSION_METHOD(object, property)\n\n      case 'ConditionalExpression':\n        const test = await this.resolveLogicNodeExpression(\n          node.test,\n          localScope,\n        )\n        const consequent = await this.resolveLogicNodeExpression(\n          node.consequent,\n          localScope,\n        )\n        const alternate = await this.resolveLogicNodeExpression(\n          node.alternate,\n          localScope,\n        )\n        return test ? consequent : alternate\n\n      case 'CallExpression':\n        return await this.handleFunction(node, false, localScope)\n\n      case 'NewExpression':\n        throw this.expressionError(errors.unsupportedOperator('new'), node)\n\n      default:\n        throw this.expressionError(\n          errors.unsupportedExpressionType(node.type),\n          node,\n        )\n    }\n  }\n\n  private parseBaseNodeChildren = async (\n    children: TemplateNode[] | undefined,\n    localScope: Scope,\n  ): Promise<string> => {\n    const parsedChildren: string[] = []\n    const childrenScope = localScope.copy()\n    for (const child of children || []) {\n      const parsedChild = await this.parseBaseNode(child, childrenScope)\n      parsedChildren.push(parsedChild)\n    }\n    return parsedChildren.join('') || ''\n  }\n\n  private baseNodeError(\n    { code, message }: { code: string; message: string },\n    node: BaseNode,\n  ): never {\n    error(message, {\n      name: 'CompileError',\n      code,\n      source: this.sql || '',\n      start: node.start || 0,\n      end: node.end || undefined,\n    })\n  }\n\n  private expressionError(\n    { code, message }: { code: string; message: string },\n    node: Node,\n  ): never {\n    const source = (node.loc?.source ?? this.sql)!.split('\\n')\n    const start =\n      source\n        .slice(0, node.loc?.start.line! - 1)\n        .reduce((acc, line) => acc + line.length + 1, 0) +\n      node.loc?.start.column!\n    const end =\n      source\n        .slice(0, node.loc?.end.line! - 1)\n        .reduce((acc, line) => acc + line.length + 1, 0) + node.loc?.end.column!\n\n    error(message, {\n      name: 'CompileError',\n      code,\n      source: this.sql || '',\n      start,\n      end,\n    })\n  }\n\n  private handleFunction = async <T extends boolean>(\n    node: SimpleCallExpression,\n    interpolation: T,\n    localScope: Scope,\n  ): Promise<T extends true ? string : unknown> => {\n    const methodName = (node.callee as Identifier).name\n    if (!this.supportedMethods.hasOwnProperty(methodName)) {\n      this.expressionError(errors.unknownFunction(methodName), node)\n    }\n    const method = this.supportedMethods[methodName]! as SupportedMethod\n    const args: unknown[] = []\n    for (const arg of node.arguments) {\n      args.push(await this.resolveLogicNodeExpression(arg, localScope))\n    }\n    try {\n      const returnedValue = (await method(\n        interpolation,\n        ...args,\n      )) as T extends true ? string : unknown\n      if (interpolation && typeof returnedValue !== 'string') {\n        this.expressionError(errors.invalidFunctionResultInterpolation, node)\n      }\n      return returnedValue\n    } catch (error: unknown) {\n      if (error instanceof CompileError) throw error\n      this.expressionError(\n        errors.functionCallError(methodName, (error as Error).message),\n        node,\n      )\n    }\n  }\n}\n","import { Compiler, ResolveFn, type SupportedMethod } from './compiler'\n\nexport type CompileParams = {\n  query: string,\n  resolveFn: ResolveFn,\n  supportedMethods?: Record<string, SupportedMethod>\n}\n\nexport default function compile({ query, supportedMethods, resolveFn }: CompileParams): Promise<string> {\n  return new Compiler({\n    query,\n    supportedMethods,\n    resolveFn\n  }).compile()\n}\n\nexport { default as CompileError } from './error/error'\nexport { type SupportedMethod } from './compiler'"],"names":["PARSER_ERRORS"],"mappings":";;;;AAeqB,MAAA,YAAa,SAAQ,KAAK,CAAA;AAC7C,IAAA,IAAI,CAAS;AACb,IAAA,KAAK,CAAW;AAChB,IAAA,GAAG,CAAW;AACd,IAAA,GAAG,CAAS;AACZ,IAAA,KAAK,CAAS;IAEd,QAAQ,GAAA;QACN,IAAI,CAAC,IAAI,CAAC,KAAK;YAAE,OAAO,IAAI,CAAC,OAAO,CAAA;QACpC,OAAO,CAAA,EAAG,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,MAAM,IAAI,CAAC,KAAK,CAAA,CAAE,CAAA;KAClF;AACF,CAAA;AAED,SAAS,YAAY,CAAC,GAAW,EAAA;IAC/B,OAAO,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAA;AACrE,CAAC;AAED,SAAS,YAAY,CACnB,MAAc,EACd,IAAY,EACZ,WAAmB,EACnB,SAA6B,EAAA;IAE7B,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;AAChC,IAAA,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,CAAA;AACxC,IAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAA;IACjD,MAAM,MAAM,GAAG,MAAM,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,MAAM,CAAA;AAC1C,IAAA,OAAO,KAAK;AACT,SAAA,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC;AAC3B,SAAA,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,KAAI;AACd,QAAA,MAAM,WAAW,GAAG,UAAU,GAAG,CAAC,KAAK,IAAI,CAAA;AAC3C,QAAA,MAAM,OAAO,GAAG,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,GAAG,CAAC,CAAA;QAChE,IAAI,WAAW,EAAE;YACf,MAAM,SAAS,GACb,GAAG,CAAC,MAAM,CACR,MAAM,GAAG,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,MAAM,CAC5D;gBACD,GAAG;gBACH,GAAG,CAAC,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,GAAG,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;YACtE,OAAO,CAAA,EAAG,OAAO,CAAA,EAAA,EAAK,YAAY,CAAC,GAAG,CAAC,CAAA,IAAA,EAAO,SAAS,CAAA,CAAE,CAAA;SAC1D;QACD,OAAO,CAAA,EAAG,OAAO,CAAK,EAAA,EAAA,YAAY,CAAC,GAAG,CAAC,EAAE,CAAA;AAC3C,KAAC,CAAC;SACD,IAAI,CAAC,IAAI,CAAC,CAAA;AACf,CAAC;AAEe,SAAA,KAAK,CAAC,OAAe,EAAE,KAAwB,EAAA;AAC7D,IAAA,MAAM,KAAK,GAAG,IAAI,YAAY,CAAC,OAAO,CAAC,CAAA;AACvC,IAAA,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAA;AACvB,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,CAAA;IAClE,MAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,CAAA;AAC7E,IAAA,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAA;AACvB,IAAA,KAAK,CAAC,KAAK,GAAG,KAAK,CAAA;AACnB,IAAA,KAAK,CAAC,GAAG,GAAG,GAAG,CAAA;AACf,IAAA,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAA;AACvB,IAAA,KAAK,CAAC,KAAK,GAAG,YAAY,CACxB,KAAK,CAAC,MAAM,EACZ,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,EACtB,KAAK,EAAE,MAAM,IAAI,CAAC,EAClB,GAAG,EAAE,MAAM,CACZ,CAAA;AACD,IAAA,MAAM,KAAK,CAAA;AACb;;AC7EA,aAAe;AACb,IAAA,aAAa,EAAE;AACb,QAAA,IAAI,EAAE,gBAAgB;AACtB,QAAA,OAAO,EAAE,yBAAyB;AACnC,KAAA;AACD,IAAA,kBAAkB,EAAE,CAAC,KAAa,MAAM;AACtC,QAAA,IAAI,EAAE,gBAAgB;QACtB,OAAO,EAAE,CAAe,YAAA,EAAA,KAAK,CAAG,CAAA,CAAA;KACjC,CAAC;AACF,IAAA,eAAe,EAAE,CAAC,KAAa,MAAM;AACnC,QAAA,IAAI,EAAE,kBAAkB;QACxB,OAAO,EAAE,CAAa,UAAA,EAAA,KAAK,CAAG,CAAA,CAAA;KAC/B,CAAC;AACF,IAAA,oBAAoB,EAAE;AACpB,QAAA,IAAI,EAAE,wBAAwB;AAC9B,QAAA,OAAO,EAAE,8BAA8B;AACxC,KAAA;AACD,IAAA,aAAa,EAAE;AACb,QAAA,IAAI,EAAE,gBAAgB;AACtB,QAAA,OAAO,EAAE,8BAA8B;AACxC,KAAA;AACD,IAAA,mCAAmC,EAAE,CAAC,KAAa,MAAM;AACvD,QAAA,IAAI,EAAE,0BAA0B;QAChC,OAAO,EAAE,CAAqB,kBAAA,EAAA,KAAK,CAAqC,mCAAA,CAAA;KACzE,CAAC;AACF,IAAA,+BAA+B,EAAE;AAC/B,QAAA,IAAI,EAAE,0BAA0B;AAChC,QAAA,OAAO,EAAE,gEAAgE;AAC1E,KAAA;AACD,IAAA,iCAAiC,EAAE,CAAC,KAAa,MAAM;AACrD,QAAA,IAAI,EAAE,wBAAwB;QAC9B,OAAO,EAAE,CAAqB,kBAAA,EAAA,KAAK,CAA8B,4BAAA,CAAA;KAClE,CAAC;AACF,IAAA,6BAA6B,EAAE;AAC7B,QAAA,IAAI,EAAE,wBAAwB;AAC9B,QAAA,OAAO,EACL,wEAAwE;AAC3E,KAAA;AACD,IAAA,iBAAiB,EAAE;AACjB,QAAA,IAAI,EAAE,qBAAqB;AAC3B,QAAA,OAAO,EAAE,qBAAqB;AAC/B,KAAA;AACD,IAAA,0BAA0B,EAAE;AAC1B,QAAA,IAAI,EAAE,kBAAkB;AACxB,QAAA,OAAO,EAAE,4CAA4C;AACtD,KAAA;AACD,IAAA,YAAY,EAAE;AACZ,QAAA,IAAI,EAAE,eAAe;AACrB,QAAA,OAAO,EAAE,eAAe;AACzB,KAAA;AACD,IAAA,0BAA0B,EAAE;AAC1B,QAAA,IAAI,EAAE,+BAA+B;AACrC,QAAA,OAAO,EAAE,qDAAqD;AAC/D,KAAA;AACD,IAAA,sBAAsB,EAAE;AACtB,QAAA,IAAI,EAAE,2BAA2B;AACjC,QAAA,OAAO,EAAE,2BAA2B;AACrC,KAAA;;AAGD,IAAA,aAAa,EAAE,CAAC,IAAY,MAAM;AAChC,QAAA,IAAI,EAAE,iBAAiB;QACvB,OAAO,EAAE,CAAU,OAAA,EAAA,IAAI,CAAa,WAAA,CAAA;KACrC,CAAC;AACF,IAAA,uBAAuB,EAAE,CAAC,IAAY,MAAM;AAC1C,QAAA,IAAI,EAAE,4BAA4B;QAClC,OAAO,EAAE,CAA+B,4BAAA,EAAA,IAAI,CAAE,CAAA;KAC/C,CAAC;AACF,IAAA,yBAAyB,EAAE,CAAC,IAAY,MAAM;AAC5C,QAAA,IAAI,EAAE,6BAA6B;QACnC,OAAO,EAAE,CAAgC,6BAAA,EAAA,IAAI,CAAE,CAAA;KAChD,CAAC;AACF,IAAA,yBAAyB,EAAE;AACzB,QAAA,IAAI,EAAE,6BAA6B;AACnC,QAAA,OAAO,EAAE,wDAAwD;AAClE,KAAA;AACD,IAAA,uBAAuB,EAAE,CAAC,IAAY,MAAM;AAC1C,QAAA,IAAI,EAAE,2BAA2B;QACjC,OAAO,EAAE,CAAa,UAAA,EAAA,IAAI,CAAuB,qBAAA,CAAA;KAClD,CAAC;AACF,IAAA,mBAAmB,EAAE,CAAC,IAAY,MAAM;AACtC,QAAA,IAAI,EAAE,uBAAuB;QAC7B,OAAO,EAAE,CAAa,UAAA,EAAA,IAAI,CAAmB,iBAAA,CAAA;KAC9C,CAAC;AACF,IAAA,gBAAgB,EAAE;AAChB,QAAA,IAAI,EAAE,oBAAoB;AAC1B,QAAA,OAAO,EAAE,oBAAoB;AAC9B,KAAA;AACD,IAAA,mBAAmB,EAAE,CAAC,QAAgB,MAAM;AAC1C,QAAA,IAAI,EAAE,sBAAsB;QAC5B,OAAO,EAAE,CAAyB,sBAAA,EAAA,QAAQ,CAAE,CAAA;KAC7C,CAAC;AACF,IAAA,oBAAoB,EAAE;AACpB,QAAA,IAAI,EAAE,uBAAuB;AAC7B,QAAA,OAAO,EAAE,4BAA4B;AACtC,KAAA;AACD,IAAA,eAAe,EAAE,CAAC,IAAY,MAAM;AAClC,QAAA,IAAI,EAAE,kBAAkB;QACxB,OAAO,EAAE,CAAqB,kBAAA,EAAA,IAAI,CAAE,CAAA;KACrC,CAAC;IACF,iBAAiB,EAAE,CAAC,IAAY,EAAE,OAAe,MAAM;AACrD,QAAA,IAAI,EAAE,qBAAqB;AAC3B,QAAA,OAAO,EAAE,CAAA,wBAAA,EAA2B,IAAI,CAAA,GAAA,EAAM,OAAO,CAAE,CAAA;KACxD,CAAC;AACF,IAAA,kCAAkC,EAAE;AAClC,QAAA,IAAI,EAAE,uCAAuC;AAC7C,QAAA,OAAO,EAAE,yDAAyD;AACnE,KAAA;CACF;;AC5GD;AAEc,SAAU,cAAc,CAAC,GAAW,EAAE,CAAS,EAAA;IAC3D,MAAM,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC/B,IAAA,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM;AAAE,QAAA,OAAO,IAAI,CAAC;IAElD,MAAM,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACnC,OAAO,CAAC,IAAI,IAAI,EAAE,IAAI,IAAI,GAAG,SAAS,CAAC;AACzC;;ACRO,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC;IAC9B,WAAW;IACX,OAAO;IACP,OAAO;IACP,MAAM;IACN,OAAO;IACP,OAAO;IACP,OAAO;IACP,UAAU;IACV,UAAU;IACV,SAAS;IACT,QAAQ;IACR,IAAI;IACJ,MAAM;IACN,MAAM;IACN,MAAM;IACN,QAAQ;IACR,SAAS;IACT,OAAO;IACP,SAAS;IACT,KAAK;IACL,UAAU;IACV,IAAI;IACJ,YAAY;IACZ,QAAQ;IACR,IAAI;IACJ,YAAY;IACZ,WAAW;IACX,KAAK;IACL,KAAK;IACL,MAAM;IACN,SAAS;IACT,SAAS;IACT,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,OAAO;IACP,MAAM;IACN,KAAK;IACL,QAAQ;IACR,KAAK;IACL,MAAM;IACN,OAAO;IACP,MAAM;IACN,OAAO;AACR,CAAA,CAAC;;AC/CI,SAAU,WAAW,CAAC,MAAc,EAAA;AACxC,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IAE3B,IAAI,IAAI,GAAG,EAAE,CAAC;IAEd,OAAO,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;AAC5C,QAAA,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YAC3B,MAAM;SACP;QACD,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;KACzC;AAED,IAAA,MAAM,IAAI,GAAG;QACX,KAAK;QACL,GAAG,EAAE,MAAM,CAAC,KAAK;AACjB,QAAA,IAAI,EAAE,SAAS;AACf,QAAA,GAAG,EAAE,IAAI;AACT,QAAA,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;KACxB,CAAC;IAEF,MAAM,CAAC,OAAO,EAAE,CAAC,QAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACxC;;ACpBM,SAAU,gBAAgB,CAAC,MAAc,EAAA;AAC7C,IAAA,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACtB,QAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,sBAAsB,CAAC,CAAA;KACnD;AAED,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IAE3B,OAAO,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;AAC5C,QAAA,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AAC7B,YAAA,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC;YAClB,MAAM;SACP;QACD,MAAM,CAAC,KAAK,EAAE,CAAA;KACf;AAED,IAAA,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;AAE5D,IAAA,MAAM,IAAI,GAAG;QACX,KAAK;AACL,QAAA,GAAG,EAAE,MAAM,CAAC,KAAK,GAAG,CAAC;AACrB,QAAA,IAAI,EAAE,SAAS;AACf,QAAA,GAAG,EAAE,IAAI;AACT,QAAA,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;KACzC,CAAC;IAEF,MAAM,CAAC,OAAO,EAAE,CAAC,QAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AACvC;;ACpBO,MAAM,iBAAiB,GAAG,CAAC,MAAc,EAAE,KAAa,KAC7D,QAAQ,CAAC,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE;AACxC,IAAA,UAAU,EAAE,QAAQ;AACpB,IAAA,WAAW,EAAE,EAAE;AACf,IAAA,SAAS,EAAE,IAAI;AAChB,CAAA,CAAC;;ACToB,SAAA,cAAc,CAAC,MAAc,EAAA;AACnD,IAAA,IAAI;AACF,QAAA,MAAM,IAAI,GAAG,iBAAiB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;QAE9D,IAAI,cAAc,GAAG,CAAC,CAAC;AAEvB,QAAA,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,EAAE;AACjD,YAAA,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG;gBAAE,cAAc,IAAI,CAAC,CAAC;SACrD;AAED,QAAA,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC;AACrB,QAAA,OAAO,cAAc,GAAG,CAAC,EAAE;YACzB,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;AAEnC,YAAA,IAAI,IAAI,KAAK,GAAG,EAAE;gBAChB,cAAc,IAAI,CAAC,CAAC;aACrB;iBAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAK,CAAC,EAAE;AAC5B,gBAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;aACzD;YAED,KAAK,IAAI,CAAC,CAAC;SACZ;AAED,QAAA,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AAErB,QAAA,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,GAAG,EAAE;AACZ,QAAA,MAAM,CAAC,UAAU,CAAC,GAAmB,CAAC,CAAC;KACxC;AACH;;AClCA,MAAM,mBAAmB,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC9C,MAAM,oBAAoB,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC/C,MAAM,kBAAkB,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7C,MAAM,mBAAmB,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAExC,SAAU,aAAa,CAAC,IAAY,EAAA;AACxC,IAAA,OAAO,IAAI,KAAK,mBAAmB,IAAI,IAAI,KAAK,kBAAkB,CAAC;AACrE,CAAC;AAEK,SAAU,cAAc,CAAC,IAAY,EAAA;AACzC,IAAA,OAAO,IAAI,KAAK,oBAAoB,IAAI,IAAI,KAAK,mBAAmB,CAAC;AACvE,CAAC;AAEe,SAAA,aAAa,CAAC,IAAY,EAAE,KAAa,EAAA;IACvD,QACE,CAAC,IAAI,KAAK,mBAAmB,IAAI,KAAK,KAAK,oBAAoB;SAC9D,IAAI,KAAK,kBAAkB,IAAI,KAAK,KAAK,mBAAmB,CAAC,EAC9D;AACJ,CAAC;AAEK,SAAU,eAAe,CAAC,IAAY,EAAA;AAC1C,IAAA,IAAI,IAAI,KAAK,mBAAmB,EAAE;AAChC,QAAA,OAAO,oBAAoB,CAAC;KAC7B;AACD,IAAA,IAAI,IAAI,KAAK,kBAAkB,EAAE;AAC/B,QAAA,OAAO,mBAAmB,CAAC;KAC5B;AACH;;AC3BA;AAewB,SAAA,WAAW,CAAC,MAAc,EAAA;AAChD,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;AAC3B,IAAA,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC;IAErB,MAAM,IAAI,GAAG,cAAc,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAChD,IAAA,IAAI,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;QACjC,OAAO;AACL,YAAA,IAAI,EAAE,YAAY;AAClB,YAAA,IAAI,EAAE,MAAM,CAAC,cAAc,EAAG;YAC9B,KAAK;YACL,GAAG,EAAE,MAAM,CAAC,KAAK;SAClB,CAAC;KACH;AAED,IAAA,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE;AACxB,QAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,0BAA0B,CAAC,CAAC;KACxD;AAED,IAAA,MAAM,YAAY,GAAa,CAAC,IAAI,CAAC,CAAC;AACtC,IAAA,CAAC,IAAI,IAAI,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;IAE5B,OAAO,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;QACjC,MAAM,IAAI,GAAG,cAAc,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AAChD,QAAA,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;AACvB,YAAA,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACzB;AAAM,aAAA,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;AAC/B,YAAA,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAE,EAAE,IAAI,CAAC,EAAE;gBAChE,MAAM,CAAC,KAAK,CACVA,MAAa,CAAC,eAAe,CAC3B,MAAM,CAAC,YAAY,CAAC,eAAe,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC,IAAI,CAAC,CAAC,CAClF,CACF,CAAC;aACH;YACD,YAAY,CAAC,GAAG,EAAE,CAAC;AACnB,YAAA,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;AAC7B,gBAAA,CAAC,IAAI,IAAI,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC5B,MAAM;aACP;SACF;AACD,QAAA,CAAC,IAAI,IAAI,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;KAC7B;AAED,IAAA,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;AAEjB,IAAA,MAAM,aAAa,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AACtD,IAAA,IAAI;;;;;;;AAOF,QAAA,IAAI,gBAAgB,GAAG,MAAM,CAAC,QAAQ;AACnC,aAAA,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC;AACf,aAAA,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QAC1B,MAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACjD,gBAAgB;AACd,YAAA,gBAAgB,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,GAAG,gBAAgB,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;AAEjF,QAAA,OAAO,iBAAiB,CAAC,CAAG,EAAA,gBAAgB,IAAI,aAAa,CAAA,KAAA,CAAO,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;KACvF;IAAC,OAAO,KAAK,EAAE;AACd,QAAA,MAAM,CAAC,UAAU,CAAC,KAAqB,CAAC,CAAC;KAC1C;IAED,OAAO;AACL,QAAA,IAAI,EAAE,YAAY;AAClB,QAAA,IAAI,EAAE,EAAE;QACR,KAAK,EAAE,MAAM,CAAC,KAAK;QACnB,GAAG,EAAE,MAAM,CAAC,KAAK;KAClB,CAAC;AACJ;;AC/EM,SAAU,QAAQ,CAAC,MAAc,EAAA;AACrC,IAAA,IAAI,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AACrB,QAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,0BAA0B,CAAC,CAAC;KACxD;AACD,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;AAC3B,IAAA,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC;IAClB,MAAM,CAAC,eAAe,EAAE,CAAC;;AAEzB,IAAA,IAAI,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AACnB,QAAA,IAAI,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;AAC7B,QAAA,IAAI,QAAgB,CAAA;AACpB,QAAA,IACE,KAAK,CAAC,IAAI,KAAK,WAAW,EAC1B;AACA,YAAA,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC;AAClB,YAAA,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AACnB,YAAA,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;YACzB,QAAQ,GAAG,MAAM,CAAC;SACnB;AACD,QAAA,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;YAC5B,QAAQ,GAAG,IAAI,CAAC;SACjB;AAAM,aAAA,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;YACrC,QAAQ,GAAG,MAAM,CAAC;SACnB;aAAM;AACL,YAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,oBAAoB,CAAC,CAAC;SAClD;AACD,QAAA,MAAM,CAAC,GAAG,CAAC,QAAS,EAAE,IAAI,CAAC,CAAC;QAC5B,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,QAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACtB,QAAA,OAAO,KAAK,CAAC,MAAM,EAAE;AACnB,YAAA,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC;AACzB,YAAA,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AACnB,YAAA,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;AACzB,YAAA,IAAI,KAAK,CAAC,IAAI,EAAE;AACd,gBAAA,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC;aACxB;SACF;;AAED,QAAA,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAM,GAAG,CAAC,CAAC,CAAC;QACrD,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAChD,MAAM,UAAU,GAAG,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACxD,MAAM,SAAS,GAAG,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AACrD,QAAA,cAAc,CAAC,KAAK,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;AAC7C,QAAA,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC;AACzB,QAAA,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;KACpB;AAAM,SAAA,IAAI,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;AAC9B,QAAA,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACpB,YAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,aAAa,CAAC,CAAC;SAC3C;QACD,MAAM,CAAC,eAAe,EAAE,CAAC;;AAEzB,QAAA,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AACpB,YAAA,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;AAC/B,YAAA,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;AAC5B,gBAAA,MAAM,CAAC,KAAK,CACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC;sBAClDA,MAAa,CAAC,mCAAmC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AACpE,sBAAEA,MAAa,CAAC,+BAA+B,CAClD,CAAC;aACH;YACD,MAAM,CAAC,iBAAiB,EAAE,CAAC;AAC3B,YAAA,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;YAC1C,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,YAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YACtB,KAAK,CAAC,IAAI,GAAG;gBACX,KAAK,EAAE,MAAM,CAAC,KAAK;AACnB,gBAAA,GAAG,EAAE,IAAI;AACT,gBAAA,IAAI,EAAE,WAAW;AACjB,gBAAA,QAAQ,EAAE;AACR,oBAAA;wBACE,KAAK,EAAE,MAAM,CAAC,KAAK;AACnB,wBAAA,GAAG,EAAE,IAAI;AACT,wBAAA,IAAI,EAAE,SAAS;AACf,wBAAA,MAAM,EAAE,IAAI;wBACZ,UAAU;AACV,wBAAA,QAAQ,EAAE,EAAE;AACb,qBAAA;AACF,iBAAA;aACF,CAAC;AACF,YAAA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3C;aAAM;;AAEL,YAAA,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;AAC/B,YAAA,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;gBAC1D,MAAM,CAAC,KAAK,CACV,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,KAAK,WAAW,CAAC;sBAChFA,MAAa,CAAC,iCAAiC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAClE,sBAAEA,MAAa,CAAC,6BAA6B,CAChD,CAAC;aACH;YACD,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,YAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YACtB,KAAK,CAAC,IAAI,GAAG;gBACX,KAAK,EAAE,MAAM,CAAC,KAAK;AACnB,gBAAA,GAAG,EAAE,IAAI;AACT,gBAAA,IAAI,EAAE,WAAW;AACjB,gBAAA,QAAQ,EAAE,EAAE;aACb,CAAC;YACF,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC/B;KACF;AAAM,SAAA,IAAI,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;;QAE1B,MAAM,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAC7B,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AACjC,QAAA,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE;AACpB,YAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,iBAAiB,CAAC,CAAC;SAC/C;QACD,MAAM,IAAI,GAAG,IAAI,GAAG,SAAS,GAAG,WAAW,CAAA;QAC3C,MAAM,CAAC,iBAAiB,EAAE,CAAC;AAC3B,QAAA,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;AAC1C,QAAA,MAAM,KAAK,GAAiB;YAC1B,KAAK;AACL,YAAA,GAAG,EAAE,KAAK;YACV,IAAI;YACJ,UAAU;AACV,YAAA,QAAQ,EAAE,EAAE;SACb,CAAA;QACD,MAAM,CAAC,eAAe,EAAE,CAAC;;AAEzB,QAAA,IAAI,IAAI,KAAK,WAAW,EAAE;AACxB,YAAA,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACvB,MAAM,CAAC,iBAAiB,EAAE,CAAC;YAC3B,KAAK,CAAC,SAAS,CAAC,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;YACvC,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,YAAA,IAAI,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACnB,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,gBAAA,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,cAAc,EAAE,CAAC;gBACtC,IAAI,CAAC,KAAK,CAAC,KAAK;AAAE,oBAAA,MAAM,CAAC,KAAK,CAACA,MAAa,CAAC,YAAY,CAAC,CAAC;gBAC3D,MAAM,CAAC,eAAe,EAAE,CAAC;aAC1B;AACD,YAAA,IAAI,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACnB,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,gBAAA,KAAK,CAAC,GAAG,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;gBACnC,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,gBAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBACtB,MAAM,CAAC,eAAe,EAAE,CAAC;aAC1B;SACF;AACD,QAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,OAAO,EAAE,CAAC,QAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACvC,QAAA,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC1B;AAAM,SAAA,IAAI,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;;QAE/B,MAAM,CAAC,iBAAiB,EAAE,CAAC;AAC3B,QAAA,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;AAC1C,QAAA,IAAI,EAAE,UAAU,CAAC,IAAI,KAAK,sBAAsB,IAAI,UAAU,CAAC,QAAQ,KAAK,GAAG,CAAC,EAAE;YAChF,MAAM,CAAC,KAAK,CACV;AACE,gBAAA,IAAI,EAAE,oBAAoB;AAC1B,gBAAA,OAAO,EAAE,qCAAqC;aAC/C,EACD,KAAK,CACN,CAAC;SACH;QACD,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,QAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACtB,QAAA,MAAM,CAAC,OAAO,EAAE,CAAC,QAAS,CAAC,IAAI,CAAC;YAC9B,KAAK;YACL,GAAG,EAAE,MAAM,CAAC,KAAK;AACjB,YAAA,IAAI,EAAE,UAAU;YAChB,UAAU;AACX,SAAA,CAAC,CAAC;KACJ;SAAM;AACL,QAAA,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;QAC1C,MAAM,CAAC,eAAe,EAAE,CAAC;AACzB,QAAA,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACtB,QAAA,MAAM,CAAC,OAAO,EAAE,CAAC,QAAS,CAAC,IAAI,CAAC;YAC9B,KAAK;YACL,GAAG,EAAE,MAAM,CAAC,KAAK;AACjB,YAAA,IAAI,EAAE,aAAa;YACnB,UAAU;AACX,SAAA,CAAC,CAAC;KACJ;AACH,CAAC;AAED,SAAS,cAAc,CAAC,KAAmB,EAAE,aAAsB,KAAK,EAAE,YAAqB,KAAK,EAAA;IAClG,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC;AAAE,QAAA,OAAO;IAC3D,MAAM,UAAU,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAE,CAAC;AACtC,IAAA,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC;IAC7D,IAAI,UAAU,CAAC,IAAI,KAAK,MAAM,IAAI,UAAU,EAAE;AAC5C,QAAA,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;QAC7D,IAAI,CAAC,UAAU,CAAC,IAAI;AAAE,YAAA,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;KAC9C;IACD,IAAI,SAAS,CAAC,IAAI,KAAK,MAAM,IAAI,SAAS,EAAE;AAC1C,QAAA,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAA;QAC1D,IAAI,CAAC,SAAS,CAAC,IAAI;AAAE,YAAA,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;KAC3C;AACD,IAAA,IAAI,KAAK,CAAC,IAAI,EAAE;QACd,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;KACnD;AACD,IAAA,IAAI,UAAU,CAAC,MAAM,EAAE;AACrB,QAAA,cAAc,CAAC,UAAU,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;KACnD;AACH,CAAC;AAED,SAAS,QAAQ,CAAC,IAAkB,EAAA;AAClC,IAAA,QAAQ,IAAI,CAAC,IAAI;AACf,QAAA,KAAK,SAAS;AACZ,YAAA,OAAO,aAAa,CAAA;AACtB,QAAA,KAAK,WAAW;AACd,YAAA,OAAO,eAAe,CAAA;AACxB,QAAA,KAAK,WAAW;AACd,YAAA,OAAO,eAAe,CAAA;AACxB,QAAA,KAAK,UAAU;AACb,YAAA,OAAO,cAAc,CAAA;AACvB,QAAA;YACE,OAAO,IAAI,CAAC,IAAI,CAAC;KACpB;AACH;;ACpNA,MAAM,uBAAuB,GAAG,OAAO,CAAC;AACxC,SAAS,YAAY,CAAC,MAAc,EAAE,IAAY,EAAA;IAChD,IAAI,IAAI,GAAG,EAAE,CAAC;IAEd,OAAO,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;AAC5C,QAAA,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,EAAE;YAC1F,MAAM;SACP;QACD,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;KACzC;IAED,MAAM,CAAC,KAAK,EAAE,CAAA;AACd,IAAA,OAAO,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;AAC5B,CAAC;AAED,MAAM,sBAAsB,GAAG,mBAAmB,CAAC;AACnD,MAAM,mBAAmB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAEnD,SAAU,IAAI,CAAC,MAAc,EAAA;AACjC,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IAC3B,IAAI,IAAI,GAAG,EAAE,CAAC;IAEd,OAAO,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;QAC5C,MAAM,UAAU,GAAG,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACrD,QAAA,IAAI,UAAU;AAAE,YAAA,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAEzC,QAAA,IAAI,CAAC,UAAU,IAAI,mBAAmB,CAAC,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE;YAC3E,MAAK;SACN;QACD,IAAI,CAAC,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,uBAAuB,CAAC,EAAE;AAC7D,YAAA,IAAI,IAAI,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAE,CAAC,CAAA;YAC9D,SAAS;SACV;QACD,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAA;KACxC;AAED,IAAA,MAAM,IAAI,GAAG;QACX,KAAK;QACL,GAAG,EAAE,MAAM,CAAC,KAAK;AACjB,QAAA,IAAI,EAAE,MAAM;AACZ,QAAA,GAAG,EAAE,IAAI;AACT,QAAA,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC;KACnE,CAAC;IAEF,MAAM,CAAC,OAAO,EAAE,CAAC,QAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACxC;;ACzCwB,SAAA,QAAQ,CAAC,MAAc,EAAA;AAC7C,IAAA,IAAI,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC1C,QAAA,OAAO,QAAQ,CAAC;KACjB;AACD,IAAA,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC5C,QAAA,OAAO,gBAAgB,CAAA;KACxB;AACD,IAAA,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACtB,QAAA,OAAO,WAAW,CAAA;KACnB;AAED,IAAA,OAAO,IAAI,CAAA;AACb;;ACRwB,SAAA,KAAK,CAAC,QAAgB,EAAA;IAC5C,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,KAAK,EAAE,CAAA;AACrC,CAAC;MAIY,MAAM,CAAA;AAIE,IAAA,QAAA,CAAA;IAHnB,KAAK,GAAW,CAAC,CAAA;IACjB,KAAK,GAAmB,EAAE,CAAA;AAE1B,IAAA,WAAA,CAAmB,QAAgB,EAAA;QAAhB,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAQ;KAAI;IAEvC,KAAK,GAAA;AACH,QAAA,MAAM,QAAQ,GAAa;AACzB,YAAA,KAAK,EAAE,CAAC;AACR,YAAA,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM;AACzB,YAAA,IAAI,EAAE,UAAU;AAChB,YAAA,QAAQ,EAAE,EAAE;SACb,CAAA;AACD,QAAA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAEzB,IAAI,KAAK,GAAgB,QAAQ,CAAA;QACjC,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;AACxC,YAAA,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAA;SAChC;QACD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACzB,YAAA,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAA;YAC9B,IAAI,CAAC,KAAK,CACR;AACE,gBAAA,IAAI,EAAE,CAAgB,cAAA,CAAA;AACtB,gBAAA,OAAO,EAAE,CAAqB,mBAAA,CAAA;AAC/B,aAAA,EACD,OAAO,CAAC,KAAM,CACf,CAAA;SACF;AACD,QAAA,IAAI,KAAK,KAAK,QAAQ,EAAE;YACtB,IAAI,CAAC,KAAK,CAAC;AACT,gBAAA,IAAI,EAAE,CAAgB,cAAA,CAAA;AACtB,gBAAA,OAAO,EAAE,CAAyB,uBAAA,CAAA;AACnC,aAAA,CAAC,CAAA;SACH;AACD,QAAA,IAAI,QAAQ,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC5B,IAAI,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAE,CAAC,KAAM,CAAA;YACxC,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAAE,KAAK,IAAI,CAAC,CAAA;AAC7C,YAAA,IAAI,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC,GAAI,CAAA;YAC/D,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBAAE,GAAG,IAAI,CAAC,CAAA;AAC7C,YAAA,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAA;AACtB,YAAA,QAAQ,CAAC,GAAG,GAAG,GAAG,CAAA;SACnB;aAAM;YACL,QAAQ,CAAC,KAAK,GAAG,QAAQ,CAAC,GAAG,GAAG,IAAI,CAAA;SACrC;AAED,QAAA,OAAO,QAAQ,CAAA;KAChB;IAED,OAAO,GAAA;AACL,QAAA,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAE,CAAA;KAC1C;AAED,IAAA,KAAK,CAAC,GAAW,EAAA;QACf,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAA;KACxE;IAED,eAAe,GAAA;QACb,OACE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM;AACjC,YAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,EAC1C;YACA,IAAI,CAAC,KAAK,EAAE,CAAA;SACb;KACF;IAED,iBAAiB,GAAA;AACf,QAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAE,CAAC,EAAE;YAC1C,IAAI,CAAC,KAAK,CAAC;AACT,gBAAA,IAAI,EAAE,oBAAoB;AAC1B,gBAAA,OAAO,EAAE,qBAAqB;AAC/B,aAAA,CAAC,CAAA;SACH;QACD,IAAI,CAAC,eAAe,EAAE,CAAA;KACvB;AAED,IAAA,GAAG,CACD,GAAW,EACX,QAAoB,GAAA,KAAK,EACzB,KAAyC,EAAA;AAEzC,QAAA,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AACnB,YAAA,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,MAAM,CAAA;AACxB,YAAA,OAAO,IAAI,CAAA;SACZ;QACD,IAAI,QAAQ,EAAE;YACZ,IAAI,CAAC,KAAK,CACR,KAAK;iBACF,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM;AAClC,sBAAEA,MAAa,CAAC,kBAAkB,CAAC,GAAG,CAAC;sBACrCA,MAAa,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,CAC1C,CAAA;SACF;AACD,QAAA,OAAO,KAAK,CAAA;KACb;IAED,KAAK,CACH,EAAE,IAAI,EAAE,OAAO,EAAqC,EACpD,KAAK,GAAG,IAAI,CAAC,KAAK,EAAA;QAElB,KAAK,CAAC,OAAO,EAAE;AACb,YAAA,IAAI,EAAE,YAAY;YAClB,IAAI;YACJ,MAAM,EAAE,IAAI,CAAC,QAAQ;YACrB,KAAK,EAAE,KAAK,GAAG,CAAC;AACjB,SAAA,CAAC,CAAA;KACH;AAED,IAAA,UAAU,CAAC,GAAiB,EAAA;QAC1B,IAAI,CAAC,KAAK,CACR;AACE,YAAA,IAAI,EAAE,aAAa;YACnB,OAAO,EAAE,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;AAClD,SAAA,EACD,GAAG,CAAC,GAAG,CACR,CAAA;KACF;AAED,IAAA,UAAU,CAAC,OAAe,EAAA;AACxB,QAAA,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA;AAC3D,QAAA,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC;AAAE,YAAA,OAAO,IAAI,CAAA;AAC5C,QAAA,OAAO,KAAK,CAAC,CAAC,CAAC,CAAA;KAChB;AAED,IAAA,IAAI,CAAC,OAAe,EAAA;QAClB,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;AACvC,QAAA,IAAI,MAAM;AAAE,YAAA,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC,MAAM,CAAA;AACvC,QAAA,OAAO,MAAM,CAAA;KACd;IAED,cAAc,CAAC,gBAAyB,KAAK,EAAA;AAC3C,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAA;AACxB,QAAA,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAA;QAClB,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAA;AAC7C,QAAA,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC;AAAE,YAAA,OAAO,IAAI,CAAA;AAC/C,QAAA,CAAC,IAAI,IAAI,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,CAAA;QAC3B,OAAO,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC/B,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAA;AAC7C,YAAA,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC;gBAAE,MAAK;AACxC,YAAA,CAAC,IAAI,IAAI,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,CAAA;SAC5B;QACD,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,EAAE,CAAA;QACpE,IAAI,CAAC,aAAa,IAAI,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YAC9C,IAAI,CAAC,KAAK,CACR;AACE,gBAAA,IAAI,EAAE,0BAA0B;gBAChC,OAAO,EAAE,CAAI,CAAA,EAAA,UAAU,CAA4D,0DAAA,CAAA;aACpF,EACD,KAAK,CACN,CAAA;SACF;AACD,QAAA,OAAO,UAAU,CAAA;KAClB;AACF;;ACzKD;AACO,MAAM,uBAAuB,GAEhC;;IAEF,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,KAAK,KAAK;IACtC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,KAAK,KAAK;IACtC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,KAAK,KAAK;IACtC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,GAAG,KAAK;IAClC,EAAE,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IAClC,UAAU,EAAE,CAAC,IAAI,EAAE,KAAK,KAAM,IAAe,YAAY,KAAK;;IAG9D,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;IACpC,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,KAAK,IAAI,IAAI,KAAK;CACrC,CAAA;AAED;AACO,MAAM,sBAAsB,GAE/B;;AAEF,IAAA,GAAG,EAAE,CAAC,KAAK,EAAE,MAAM,MAAM,MAAM,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC;AACjD,IAAA,GAAG,EAAE,CAAC,KAAK,EAAE,MAAM,MAAM,MAAM,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC;IACjD,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,KAAK;IACzB,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,KAAK;IACzB,MAAM,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,OAAO,KAAK;IAClC,IAAI,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,KAAK,KAAK;CAC/B,CAAA;AAED;AACO,MAAM,wBAAwB,GAAG,CAAC,MAAW,EAAE,QAAa,KACjE,MAAM,CAAC,QAAQ,CAAC,CAAA;AAElB;AACO,MAAM,2BAA2B,GAEpC;AACF,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,KAAK,KAAK,CAAC;AACxC,IAAA,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,KAAK,KAAK,CAAC;AACxC,IAAA,MAAM,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,MAAM,KAAK,CAAC;AAC1C,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;AACtC,IAAA,IAAI,EAAE,CAAC,IAAI,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC;CACvC;;ACjEa,MAAO,KAAK,CAAA;AAKd,IAAA,aAAA,CAAA;AACA,IAAA,UAAA,CAAA;AACA,IAAA,WAAA,CAAA;IANF,MAAM,GAA2B,EAAE,CAAA;IACnC,IAAI,GAA2B,EAAE,CAAA;AAEzC,IAAA,WAAA,CACU,aAAyC,EACzC,UAAsC,EACtC,WAAoD,EAAA;QAFpD,IAAa,CAAA,aAAA,GAAb,aAAa,CAA4B;QACzC,IAAU,CAAA,UAAA,GAAV,UAAU,CAA4B;QACtC,IAAW,CAAA,WAAA,GAAX,WAAW,CAAyC;KAC1D;AAEJ,IAAA,MAAM,CAAC,IAAY,EAAA;QACjB,OAAO,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,CAAA;KAChD;AAED,IAAA,OAAO,CAAC,IAAY,EAAA;AAClB,QAAA,OAAO,IAAI,IAAI,IAAI,CAAC,MAAM,CAAA;KAC3B;AAED,IAAA,GAAG,CAAC,IAAY,EAAA;AACd,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,SAAS,CAAA;QAC/D,IAAI,KAAK,KAAK,SAAS;AAAE,YAAA,MAAM,IAAI,KAAK,CAAC,YAAY,IAAI,CAAA,eAAA,CAAiB,CAAC,CAAA;AAC3E,QAAA,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;KACjC;IAED,WAAW,CAAC,IAAY,EAAE,KAAc,EAAA;AACtC,QAAA,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;AAAE,YAAA,MAAM,IAAI,KAAK,CAAC,YAAY,IAAI,CAAA,eAAA,CAAiB,CAAC,CAAA;AACzE,QAAA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;KAC3C;IAED,GAAG,CAAC,IAAY,EAAE,KAAc,EAAA;AAC9B,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;AAAE,YAAA,MAAM,IAAI,KAAK,CAAC,YAAY,IAAI,CAAA,cAAA,CAAgB,CAAC,CAAA;QACzE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;AACtB,YAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;YACxC,OAAM;SACP;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAE,CAAA;AAC9B,QAAA,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;KAC/B;IAED,IAAI,GAAA;AACF,QAAA,MAAM,KAAK,GAAG,IAAI,KAAK,CACrB,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,WAAW,CACjB,CAAA;QACD,KAAK,CAAC,MAAM,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAA;QACjC,KAAK,CAAC,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;AAC7B,QAAA,OAAO,KAAK,CAAA;KACb;AACF;;MCzBY,QAAQ,CAAA;AACX,IAAA,GAAG,CAAQ;AACX,IAAA,gBAAgB,CAAiC;AACjD,IAAA,SAAS,CAAW;AAEpB,IAAA,QAAQ,CAAW;AAEnB,IAAA,aAAa,CAAC,KAAa,EAAA;AACjC,QAAA,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;KAC5B;AAEO,IAAA,UAAU,CAAC,KAAc,EAAA;AAC/B,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AACzB,QAAA,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAA;KAChC;IAEO,WAAW,CAAC,KAAa,EAAE,KAAc,EAAA;AAC/C,QAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,KAAK,CAAA;KAC7B;IAED,WAAY,CAAA,EAAE,KAAK,EAAE,SAAS,EAAE,gBAAgB,GAAG,EAAE,EAAiB,EAAA;AACpE,QAAA,IAAI,CAAC,GAAG,GAAG,KAAK,CAAA;AAChB,QAAA,IAAI,CAAC,SAAS,GAAG,SAAS,CAAA;AAC1B,QAAA,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAA;AAExC,QAAA,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAA;KACnB;AAED,IAAA,MAAM,OAAO,GAAA;QACX,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AAChC,QAAA,MAAM,UAAU,GAAG,IAAI,KAAK,CAC1B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAC7B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAC1B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAC5B,CAAA;AACD,QAAA,MAAM,WAAW,GAAG,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,UAAU,CAAC;AAChE,aAAA,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;aACnB,IAAI,EAAE,CAAA;AAET,QAAA,OAAO,WAAW,CAAA;KACnB;AAEO,IAAA,aAAa,GAAG,OACtB,IAAc,EACd,UAAiB,KACE;AACnB,QAAA,IAAI,CAAC,IAAI;AAAE,YAAA,OAAO,EAAE,CAAA;AAEpB,QAAA,QAAQ,IAAI,CAAC,IAAI;AACf,YAAA,KAAK,UAAU;gBACb,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAA;AAE9D,YAAA,KAAK,SAAS;gBACZ,OAAO,IAAI,CAAC,GAAG,CAAA;AAEjB,YAAA,KAAK,MAAM;gBACT,OAAO,IAAI,CAAC,GAAG,CAAA;AAEjB,YAAA,KAAK,aAAa;gBAChB,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,CAAA;AAE/D,YAAA,KAAK,UAAU;;AAEb,gBAAA,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAA;AAClC,gBAAA,IACE,UAAU,CAAC,IAAI,KAAK,sBAAsB;oBAC1C,UAAU,CAAC,QAAQ,KAAK,GAAG;AAC3B,oBAAA,UAAU,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,EACrC;oBACA,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC,CAAA;iBAC3D;AAED,gBAAA,MAAM,SAAS,GAAI,UAAU,CAAC,IAAmB,CAAC,IAAI,CAAA;AACtD,gBAAA,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACtD,UAAU,CAAC,KAAK,EAChB,UAAU,CACX,CAAA;AACD,gBAAA,IAAI,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE;AAChC,oBAAA,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,uBAAuB,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,CAAA;iBACpE;AACD,gBAAA,UAAU,CAAC,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,CAAA;AAC7C,gBAAA,OAAO,EAAE,CAAA;AAEX,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,CAAC,MAAM,IAAI,CAAC,0BAA0B,CAC3C,IAAI,CAAC,UAAU,EACf,UAAU,CACX;sBACG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC;AACvD,sBAAE,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;AAErD,YAAA,KAAK,WAAW;gBACd,OAAO,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAA;AAE9D,YAAA,KAAK,WAAW;AACd,gBAAA,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,0BAA0B,CAC3D,IAAI,CAAC,UAAU,EACf,UAAU,CACX,CAAA;AACD,gBAAA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;oBAC9D,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;iBACvD;AAED,gBAAA,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAA;AACpC,gBAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAA;AAC3B,gBAAA,IAAI,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE;AACjC,oBAAA,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,uBAAuB,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,CAAA;iBACrE;gBACD,IAAI,QAAQ,IAAI,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;AAC3C,oBAAA,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,uBAAuB,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAA;iBACnE;gBAED,MAAM,cAAc,GAAa,EAAE,CAAA;AACnC,gBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC/C,oBAAA,MAAM,OAAO,GAAG,eAAe,CAAC,CAAC,CAAC,CAAA;AAClC,oBAAA,IAAI,QAAQ;AAAE,wBAAA,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAA;AACzC,oBAAA,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,CAAA;AACnC,oBAAA,cAAc,CAAC,IAAI,CACjB,MAAM,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAC5D,CAAA;iBACF;gBACD,OAAO,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAA;AAEtC,YAAA;AACE,gBAAA,MAAM,IAAI,CAAC,aAAa,CACtB,MAAM,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,EACzC,IAAI,CACL,CAAA;SACJ;AACH,KAAC,CAAA;AAEO,IAAA,cAAc,GAAG,OACvB,IAAU,EACV,UAAiB,KACE;AACnB,QAAA,IAAI,IAAI,CAAC,IAAI,KAAK,sBAAsB,EAAE;YACxC,MAAM,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;AACvD,YAAA,OAAO,EAAE,CAAA;SACV;AAED,QAAA,IAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;YAClC,OAAO,MAAM,IAAI,CAAC,cAAc,CAC9B,IAA4B,EAC5B,IAAI,EACJ,UAAU,CACX,CAAA;SACF;QAED,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;QACrE,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;AAEjD,QAAA,OAAO,aAAa,CAAA;AACtB,KAAC,CAAA;AAEO,IAAA,0BAA0B,GAAG,OACnC,IAAU,EACV,UAAiB,KACG;AACpB,QAAA,QAAQ,IAAI,CAAC,IAAI;AACf,YAAA,KAAK,SAAS;gBACZ,OAAO,IAAI,CAAC,KAAK,CAAA;AAEnB,YAAA,KAAK,YAAY;gBACf,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AACjC,oBAAA,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAA;iBAClE;gBACD,OAAO,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AAElC,YAAA,KAAK,kBAAkB;gBACrB,MAAM,cAAc,GAA2B,EAAE,CAAA;AACjD,gBAAA,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;AAClC,oBAAA,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC5B,MAAM,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAA;qBAC1D;AACD,oBAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAiB,CAAA;AAClC,oBAAA,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACjD,IAAI,CAAC,KAAK,EACV,UAAU,CACX,CAAA;AACD,oBAAA,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;iBACjC;AACD,gBAAA,OAAO,cAAc,CAAA;AAEvB,YAAA,KAAK,iBAAiB;AACpB,gBAAA,OAAO,MAAM,OAAO,CAAC,GAAG,CACtB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,KACxB,OAAO;sBACH,IAAI,CAAC,0BAA0B,CAAC,OAAO,EAAE,UAAU,CAAC;AACtD,sBAAE,IAAI,CACT,CACF,CAAA;AAEH,YAAA,KAAK,oBAAoB;gBACvB,OAAO,MAAM,OAAO,CAAC,GAAG,CACtB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,KAC9B,IAAI,CAAC,0BAA0B,CAAC,UAAU,EAAE,UAAU,CAAC,CACxD,CACF,CAAA;AAEH,YAAA,KAAK,kBAAkB,CAAC;AACxB,YAAA,KAAK,mBAAmB;AACtB,gBAAA,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAA;gBACpC,IAAI,CAAC,uBAAuB,CAAC,cAAc,CAAC,cAAc,CAAC,EAAE;AAC3D,oBAAA,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,mBAAmB,CAAC,cAAc,CAAC,EAAE,IAAI,CAAC,CAAA;iBACvE;AACD,gBAAA,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACvD,IAAI,CAAC,IAAI,EACT,UAAU,CACX,CAAA;AACD,gBAAA,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACxD,IAAI,CAAC,KAAK,EACV,UAAU,CACX,CAAA;gBACD,OAAO,uBAAuB,CAAC,cAAc,CAAC,GAC5C,WAAW,EACX,YAAY,CACb,CAAA;AAEH,YAAA,KAAK,iBAAiB;AACpB,gBAAA,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAA;gBACnC,IAAI,CAAC,sBAAsB,CAAC,cAAc,CAAC,aAAa,CAAC,EAAE;AACzD,oBAAA,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,mBAAmB,CAAC,aAAa,CAAC,EAAE,IAAI,CAAC,CAAA;iBACtE;AAED,gBAAA,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACzD,IAAI,CAAC,QAAQ,EACb,UAAU,CACX,CAAA;AACD,gBAAA,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAA;gBAC/B,OAAO,sBAAsB,CAAC,aAAa,CAAC,GAC1C,aAAa,EACb,WAAW,CACZ,CAAA;AAEH,YAAA,KAAK,sBAAsB;AACzB,gBAAA,MAAM,oBAAoB,GAAI,IAAI,CAAC,IAAmB,CAAC,IAAI,CAAA;AAC3D,gBAAA,IAAI,aAAa,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACvD,IAAI,CAAC,KAAK,EACV,UAAU,CACX,CAAA;AACD,gBAAA,MAAM,kBAAkB,GAAG,IAAI,CAAC,QAAQ,CAAA;AAExC,gBAAA,IAAI,kBAAkB,IAAI,GAAG,EAAE;oBAC7B,IAAI,CAAC,2BAA2B,CAAC,cAAc,CAAC,kBAAkB,CAAC,EAAE;AACnE,wBAAA,IAAI,CAAC,eAAe,CAClB,MAAM,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,EAC9C,IAAI,CACL,CAAA;qBACF;oBACD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,oBAAoB,CAAC,EAAE;AAC5C,wBAAA,IAAI,CAAC,eAAe,CAClB,MAAM,CAAC,mBAAmB,CAAC,oBAAoB,CAAC,EAChD,IAAI,CACL,CAAA;qBACF;AACD,oBAAA,aAAa,GAAG,2BAA2B,CAAC,kBAAkB,CAAC,GAC7D,UAAU,CAAC,GAAG,CAAC,oBAAoB,CAAC,EACpC,aAAa,CACd,CAAA;iBACF;AACD,gBAAA,IAAI,UAAU,CAAC,OAAO,CAAC,oBAAoB,CAAC,EAAE;oBAC5C,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAA;iBACxD;AACD,gBAAA,UAAU,CAAC,GAAG,CAAC,oBAAoB,EAAE,aAAa,CAAC,CAAA;AACnD,gBAAA,OAAO,aAAa,CAAA;AAEtB,YAAA,KAAK,kBAAkB;AACrB,gBAAA,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAA;AACpC,gBAAA,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;AAC1C,oBAAA,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,mBAAmB,CAAC,cAAc,CAAC,EAAE,IAAI,CAAC,CAAA;iBACvE;AACD,gBAAA,MAAM,mBAAmB,GAAI,IAAI,CAAC,QAAuB,CAAC,IAAI,CAAA;gBAC9D,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,mBAAmB,CAAC,EAAE;AAC3C,oBAAA,IAAI,CAAC,eAAe,CAClB,MAAM,CAAC,mBAAmB,CAAC,mBAAmB,CAAC,EAC/C,IAAI,CACL,CAAA;iBACF;AACD,gBAAA,IAAI,UAAU,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE;oBAC3C,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAA;iBACxD;gBACD,MAAM,aAAa,GAAG,UAAU,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAA;AACzD,gBAAA,MAAM,YAAY,GAChB,cAAc,KAAK,IAAI;sBAClB,aAAwB,GAAG,CAAC;AAC/B,sBAAG,aAAwB,GAAG,CAAC,CAAA;AACnC,gBAAA,UAAU,CAAC,GAAG,CAAC,mBAAmB,EAAE,YAAY,CAAC,CAAA;gBACjD,OAAO,IAAI,CAAC,MAAM,GAAG,YAAY,GAAG,aAAa,CAAA;AAEnD,YAAA,KAAK,kBAAkB;AACrB,gBAAA,MAAM,MAAM,IAAI,MAAM,IAAI,CAAC,0BAA0B,CACnD,IAAI,CAAC,MAAM,EACX,UAAU,CACX,CAEA,CAAA;AACD,gBAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ;sBAC1B,MAAM,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC;AAClE,sBAAG,IAAI,CAAC,QAAuB,CAAC,IAAI,CAAA;AACtC,gBAAA,OAAO,wBAAwB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAA;AAEnD,YAAA,KAAK,uBAAuB;AAC1B,gBAAA,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,0BAA0B,CAChD,IAAI,CAAC,IAAI,EACT,UAAU,CACX,CAAA;AACD,gBAAA,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACtD,IAAI,CAAC,UAAU,EACf,UAAU,CACX,CAAA;AACD,gBAAA,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,0BAA0B,CACrD,IAAI,CAAC,SAAS,EACd,UAAU,CACX,CAAA;gBACD,OAAO,IAAI,GAAG,UAAU,GAAG,SAAS,CAAA;AAEtC,YAAA,KAAK,gBAAgB;gBACnB,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAA;AAE3D,YAAA,KAAK,eAAe;AAClB,gBAAA,MAAM,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAA;AAErE,YAAA;AACE,gBAAA,MAAM,IAAI,CAAC,eAAe,CACxB,MAAM,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,EAC3C,IAAI,CACL,CAAA;SACJ;AACH,KAAC,CAAA;AAEO,IAAA,qBAAqB,GAAG,OAC9B,QAAoC,EACpC,UAAiB,KACE;QACnB,MAAM,cAAc,GAAa,EAAE,CAAA;AACnC,QAAA,MAAM,aAAa,GAAG,UAAU,CAAC,IAAI,EAAE,CAAA;AACvC,QAAA,KAAK,MAAM,KAAK,IAAI,QAAQ,IAAI,EAAE,EAAE;YAClC,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,aAAa,CAAC,CAAA;AAClE,YAAA,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;SACjC;QACD,OAAO,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAA;AACtC,KAAC,CAAA;AAEO,IAAA,aAAa,CACnB,EAAE,IAAI,EAAE,OAAO,EAAqC,EACpD,IAAc,EAAA;QAEd,KAAK,CAAC,OAAO,EAAE;AACb,YAAA,IAAI,EAAE,cAAc;YACpB,IAAI;AACJ,YAAA,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,EAAE;AACtB,YAAA,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,CAAC;AACtB,YAAA,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,SAAS;AAC3B,SAAA,CAAC,CAAA;KACH;AAEO,IAAA,eAAe,CACrB,EAAE,IAAI,EAAE,OAAO,EAAqC,EACpD,IAAU,EAAA;AAEV,QAAA,MAAM,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,IAAI,IAAI,CAAC,GAAG,EAAG,KAAK,CAAC,IAAI,CAAC,CAAA;QAC1D,MAAM,KAAK,GACT,MAAM;AACH,aAAA,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAK,GAAG,CAAC,CAAC;AACnC,aAAA,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,KAAK,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;AAClD,YAAA,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,MAAO,CAAA;QACzB,MAAM,GAAG,GACP,MAAM;AACH,aAAA,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,IAAK,GAAG,CAAC,CAAC;aACjC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,KAAK,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,MAAO,CAAA;QAE5E,KAAK,CAAC,OAAO,EAAE;AACb,YAAA,IAAI,EAAE,cAAc;YACpB,IAAI;AACJ,YAAA,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,EAAE;YACtB,KAAK;YACL,GAAG;AACJ,SAAA,CAAC,CAAA;KACH;IAEO,cAAc,GAAG,OACvB,IAA0B,EAC1B,aAAgB,EAChB,UAAiB,KAC6B;AAC9C,QAAA,MAAM,UAAU,GAAI,IAAI,CAAC,MAAqB,CAAC,IAAI,CAAA;QACnD,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE;AACrD,YAAA,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,eAAe,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,CAAA;SAC/D;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAqB,CAAA;QACpE,MAAM,IAAI,GAAc,EAAE,CAAA;AAC1B,QAAA,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE;AAChC,YAAA,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,0BAA0B,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC,CAAA;SAClE;AACD,QAAA,IAAI;AACF,YAAA,MAAM,aAAa,IAAI,MAAM,MAAM,CACjC,aAAa,EACb,GAAG,IAAI,CACR,CAAsC,CAAA;AACvC,YAAA,IAAI,aAAa,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;gBACtD,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,kCAAkC,EAAE,IAAI,CAAC,CAAA;aACtE;AACD,YAAA,OAAO,aAAa,CAAA;SACrB;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,KAAK,YAAY,YAAY;AAAE,gBAAA,MAAM,KAAK,CAAA;AAC9C,YAAA,IAAI,CAAC,eAAe,CAClB,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAG,KAAe,CAAC,OAAO,CAAC,EAC9D,IAAI,CACL,CAAA;SACF;AACH,KAAC,CAAA;AACF;;AC3aa,SAAU,OAAO,CAAC,EAAE,KAAK,EAAE,gBAAgB,EAAE,SAAS,EAAiB,EAAA;IACnF,OAAO,IAAI,QAAQ,CAAC;QAClB,KAAK;QACL,gBAAgB;QAChB,SAAS;KACV,CAAC,CAAC,OAAO,EAAE,CAAA;AACd;;;;"}