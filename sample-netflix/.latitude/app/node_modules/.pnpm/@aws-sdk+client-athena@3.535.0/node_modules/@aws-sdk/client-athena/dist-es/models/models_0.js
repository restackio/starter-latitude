import { AthenaServiceException as __BaseException } from "./AthenaServiceException";
export const S3AclOption = {
    BUCKET_OWNER_FULL_CONTROL: "BUCKET_OWNER_FULL_CONTROL",
};
export class InternalServerException extends __BaseException {
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.Message = opts.Message;
    }
}
export class InvalidRequestException extends __BaseException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
        this.AthenaErrorCode = opts.AthenaErrorCode;
        this.Message = opts.Message;
    }
}
export const AuthenticationType = {
    DIRECTORY_IDENTITY: "DIRECTORY_IDENTITY",
};
export const EncryptionOption = {
    CSE_KMS: "CSE_KMS",
    SSE_KMS: "SSE_KMS",
    SSE_S3: "SSE_S3",
};
export const StatementType = {
    DDL: "DDL",
    DML: "DML",
    UTILITY: "UTILITY",
};
export const QueryExecutionState = {
    CANCELLED: "CANCELLED",
    FAILED: "FAILED",
    QUEUED: "QUEUED",
    RUNNING: "RUNNING",
    SUCCEEDED: "SUCCEEDED",
};
export const DataCatalogType = {
    GLUE: "GLUE",
    HIVE: "HIVE",
    LAMBDA: "LAMBDA",
};
export const ThrottleReason = {
    CONCURRENT_QUERY_LIMIT_EXCEEDED: "CONCURRENT_QUERY_LIMIT_EXCEEDED",
};
export class TooManyRequestsException extends __BaseException {
    constructor(opts) {
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
        this.Message = opts.Message;
        this.Reason = opts.Reason;
    }
}
export class ResourceNotFoundException extends __BaseException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        this.Message = opts.Message;
        this.ResourceName = opts.ResourceName;
    }
}
export const NotebookType = {
    IPYNB: "IPYNB",
};
export const CalculationExecutionState = {
    CANCELED: "CANCELED",
    CANCELING: "CANCELING",
    COMPLETED: "COMPLETED",
    CREATED: "CREATED",
    CREATING: "CREATING",
    FAILED: "FAILED",
    QUEUED: "QUEUED",
    RUNNING: "RUNNING",
};
export const CapacityAllocationStatus = {
    FAILED: "FAILED",
    PENDING: "PENDING",
    SUCCEEDED: "SUCCEEDED",
};
export const CapacityReservationStatus = {
    ACTIVE: "ACTIVE",
    CANCELLED: "CANCELLED",
    CANCELLING: "CANCELLING",
    FAILED: "FAILED",
    PENDING: "PENDING",
    UPDATE_PENDING: "UPDATE_PENDING",
};
export class MetadataException extends __BaseException {
    constructor(opts) {
        super({
            name: "MetadataException",
            $fault: "client",
            ...opts,
        });
        this.name = "MetadataException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MetadataException.prototype);
        this.Message = opts.Message;
    }
}
export const ColumnNullable = {
    NOT_NULL: "NOT_NULL",
    NULLABLE: "NULLABLE",
    UNKNOWN: "UNKNOWN",
};
export const SessionState = {
    BUSY: "BUSY",
    CREATED: "CREATED",
    CREATING: "CREATING",
    DEGRADED: "DEGRADED",
    FAILED: "FAILED",
    IDLE: "IDLE",
    TERMINATED: "TERMINATED",
    TERMINATING: "TERMINATING",
};
export const WorkGroupState = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export const ExecutorState = {
    CREATED: "CREATED",
    CREATING: "CREATING",
    FAILED: "FAILED",
    REGISTERED: "REGISTERED",
    TERMINATED: "TERMINATED",
    TERMINATING: "TERMINATING",
};
export const ExecutorType = {
    COORDINATOR: "COORDINATOR",
    GATEWAY: "GATEWAY",
    WORKER: "WORKER",
};
export class SessionAlreadyExistsException extends __BaseException {
    constructor(opts) {
        super({
            name: "SessionAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "SessionAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, SessionAlreadyExistsException.prototype);
        this.Message = opts.Message;
    }
}
