import path from 'path';
import * as fs from 'fs';
import compile from '@latitude-data/sql-compiler';

class ConnectorError extends Error {
}
class ConnectionError extends ConnectorError {
}
class QueryError extends ConnectorError {
}

class BaseConnector {
    rootPath;
    constructor(rootPath) {
        this.rootPath = rootPath;
    }
    async connect() { }
    async disconnect() { }
    async run(request) {
        await this.connect();
        const resolvedParams = [];
        const ranQueries = {};
        const queriesBeingCompiled = [];
        try {
            return await this._query({
                request,
                resolvedParams,
                ranQueries,
                queriesBeingCompiled,
            });
        }
        finally {
            await this.disconnect();
        }
    }
    async runCompiled(request) {
        await this.connect();
        try {
            return await this.runQuery(request);
        }
        finally {
            await this.disconnect();
        }
    }
    async compileQuery(request) {
        const resolvedParams = [];
        const ranQueries = {};
        const queriesBeingCompiled = [];
        const { compiledQuery } = await this._compileQuery({
            request,
            resolvedParams,
            ranQueries,
            queriesBeingCompiled,
        });
        return { compiledQuery, resolvedParams };
    }
    async _query({ request, resolvedParams, ranQueries, queriesBeingCompiled, }) {
        const { compiledQuery } = await this._compileQuery({
            request,
            resolvedParams,
            ranQueries,
            queriesBeingCompiled,
        });
        return this.runQuery({
            sql: compiledQuery,
            params: resolvedParams,
        });
    }
    async _compileQuery({ request, resolvedParams, ranQueries, queriesBeingCompiled, }) {
        const fullQueryName = this.fullQueryPath(request.queryPath);
        queriesBeingCompiled.push(fullQueryName);
        const query = this.readQuery(fullQueryName);
        const params = request.params || {};
        const resolveFn = async (value) => {
            const resolved = this.resolve(value, resolvedParams.length);
            resolvedParams.push(resolved);
            return resolved.resolvedAs;
        };
        const supportedMethods = this.buildSupportedMethods({
            params,
            resolveFn,
            ranQueries,
            queriesBeingCompiled,
        });
        const compiledQuery = await compile({
            query,
            resolveFn,
            supportedMethods,
        });
        // NOTE: To avoid compiling subqueries that have already been compiled in
        // the current call stack.
        queriesBeingCompiled.pop();
        return {
            compiledQuery,
            resolvedParams,
        };
    }
    fullQueryPath(queryName) {
        return path.join(this.rootPath, queryName.endsWith('.sql') ? queryName : `${queryName}.sql`);
    }
    readQuery(fullQueryPath) {
        if (!fs.existsSync(fullQueryPath))
            throw new ConnectorError(`Query file not found: ${fullQueryPath}`);
        return fs.readFileSync(fullQueryPath, 'utf8');
    }
    buildSupportedMethods({ params, resolveFn, ranQueries, queriesBeingCompiled, }) {
        const supportedMethods = {
            interpolate: async (interpolation, value) => {
                if (!interpolation) {
                    throw new Error('interpolate function cannot be used inside a logic block');
                }
                return String(value);
            },
            param: async (interpolation, name, defaultValue) => {
                if (typeof name !== 'string')
                    throw new Error('Invalid parameter name');
                if (!(name in params) && defaultValue === undefined) {
                    throw new Error(`Missing parameter '${name}' in request`);
                }
                const value = name in params ? params[name] : defaultValue;
                const resolvedValue = interpolation ? await resolveFn(value) : value;
                return resolvedValue;
            },
            unsafeParam: async (interpolation, name, defaultValue) => {
                if (!interpolation) {
                    throw new Error('unsafeParam function cannot be used inside a logic block');
                }
                if (typeof name !== 'string')
                    throw new Error('Invalid parameter name');
                if (!(name in params) && defaultValue === undefined) {
                    throw new Error(`Missing parameter '${name}' in request`);
                }
                const value = name in params ? params[name] : defaultValue;
                return String(value);
            },
            cast: async (interpolation, value, type) => {
                if (typeof type !== 'string')
                    throw new Error('Invalid cast type');
                if (!(type in CAST_METHODS)) {
                    throw new Error(`Unsupported cast type: '${type}'`);
                }
                const parsedValue = CAST_METHODS[type](value);
                const resolvedValue = interpolation
                    ? await resolveFn(parsedValue)
                    : parsedValue;
                return resolvedValue;
            },
            ref: async (interpolation, queryName) => {
                if (typeof queryName !== 'string')
                    throw new Error('Invalid query name');
                if (!interpolation) {
                    throw new Error('ref function cannot be used inside a logic block');
                }
                const fullSubQueryPath = this.fullQueryPath(queryName);
                if (queriesBeingCompiled.includes(fullSubQueryPath)) {
                    throw new Error('Query reference to a parent, resulting in cyclic references.');
                }
                queriesBeingCompiled.push(fullSubQueryPath);
                const subQuery = this.readQuery(fullSubQueryPath);
                const compiledSubQuery = await compile({
                    query: subQuery,
                    resolveFn,
                    supportedMethods,
                });
                queriesBeingCompiled.pop();
                return `(${compiledSubQuery})`;
            },
            runQuery: async (interpolation, queryName) => {
                if (typeof queryName !== 'string')
                    throw new Error('Invalid query name');
                if (interpolation) {
                    throw new Error('runQuery function cannot be directly interpolated into the query');
                }
                const fullSubQueryPath = this.fullQueryPath(queryName);
                if (fullSubQueryPath in ranQueries) {
                    return ranQueries[fullSubQueryPath];
                }
                if (queriesBeingCompiled.includes(fullSubQueryPath)) {
                    throw new Error('Query reference to a parent, resulting in cyclic references.');
                }
                const subQueryResults = (await this._query({
                    request: { queryPath: queryName, params },
                    resolvedParams: [],
                    ranQueries,
                    queriesBeingCompiled,
                })).toArray();
                ranQueries[fullSubQueryPath] = subQueryResults;
                return subQueryResults;
            },
        };
        return supportedMethods;
    }
}
const CAST_METHODS = {
    string: (value) => String(value),
    text: (value) => String(value),
    int: (value) => parseInt(value),
    float: (value) => parseFloat(value),
    number: (value) => Number(value),
    bool: (value) => Boolean(value),
    boolean: (value) => Boolean(value),
    date: (value) => new Date(value),
};

export { BaseConnector, CAST_METHODS, ConnectionError, ConnectorError, QueryError };
//# sourceMappingURL=index.js.map
