{"version":3,"file":"index.js","sources":["../src/types.ts","../src/index.ts"],"sourcesContent":["export type QueryParams = {\n  [key: string]: unknown\n}\n\nexport type QueryRequest = {\n  queryPath: string\n  params?: QueryParams\n}\n\nexport type ResolvedParam = {\n  value: unknown\n  resolvedAs: string\n}\nexport type CompiledQuery = {\n  sql: string\n  params: ResolvedParam[]\n}\n\nexport class ConnectorError extends Error {}\nexport class ConnectionError extends ConnectorError {}\nexport class QueryError extends ConnectorError {}\n","import path from 'path'\nimport * as fs from 'fs'\nimport compile, {\n  type CompileError,\n  type SupportedMethod,\n} from '@latitude-data/sql-compiler'\nimport type QueryResult from '@latitude-data/query_result'\nimport { type QueryResultArray } from '@latitude-data/query_result'\n\nimport {\n  type QueryRequest,\n  type ResolvedParam,\n  type CompiledQuery,\n  ConnectorError,\n  QueryParams,\n} from './types'\n\nexport abstract class BaseConnector {\n  private rootPath: string\n\n  constructor(rootPath: string) {\n    this.rootPath = rootPath\n  }\n\n  /**\n   * While compiling the query, the connector will call this method to resolve the\n   * parameterised string for a variable. The index is the position of this variable\n   * in the array of ResolvedParams that will be passed to the runQuery method.\n   */\n  protected abstract resolve(value: unknown, index: number): ResolvedParam\n\n  protected abstract runQuery(request: CompiledQuery): Promise<QueryResult>\n  protected async connect(): Promise<void> {}\n  protected async disconnect(): Promise<void> {}\n\n  async run(request: QueryRequest): Promise<QueryResult> {\n    await this.connect()\n\n    const resolvedParams: ResolvedParam[] = []\n    const ranQueries: Record<string, QueryResultArray> = {}\n    const queriesBeingCompiled: string[] = []\n\n    try {\n      return await this._query({\n        request,\n        resolvedParams,\n        ranQueries,\n        queriesBeingCompiled,\n      })\n    } finally {\n      await this.disconnect()\n    }\n  }\n\n  async runCompiled(request: CompiledQuery): Promise<QueryResult> {\n    await this.connect()\n\n    try {\n      return await this.runQuery(request)\n    } finally {\n      await this.disconnect()\n    }\n  }\n\n  async compileQuery(\n    request: QueryRequest,\n  ): Promise<{ compiledQuery: string; resolvedParams: ResolvedParam[] }> {\n    const resolvedParams: ResolvedParam[] = []\n    const ranQueries: Record<string, QueryResultArray> = {}\n    const queriesBeingCompiled: string[] = []\n\n    const { compiledQuery } = await this._compileQuery({\n      request,\n      resolvedParams,\n      ranQueries,\n      queriesBeingCompiled,\n    })\n\n    return { compiledQuery, resolvedParams }\n  }\n\n  private async _query({\n    request,\n    resolvedParams,\n    ranQueries,\n    queriesBeingCompiled,\n  }: {\n    request: QueryRequest\n    resolvedParams: ResolvedParam[]\n    ranQueries: Record<string, QueryResultArray> // Ran query results are cached to avoid re-running the same query\n    queriesBeingCompiled: string[] // Used to detect cyclic references\n  }): Promise<QueryResult> {\n    const { compiledQuery } = await this._compileQuery({\n      request,\n      resolvedParams,\n      ranQueries,\n      queriesBeingCompiled,\n    })\n\n    return this.runQuery({\n      sql: compiledQuery,\n      params: resolvedParams,\n    })\n  }\n\n  private async _compileQuery({\n    request,\n    resolvedParams,\n    ranQueries,\n    queriesBeingCompiled,\n  }: {\n    request: QueryRequest\n    resolvedParams: ResolvedParam[]\n    ranQueries: Record<string, QueryResultArray> // Ran query results are cached to avoid re-running the same query\n    queriesBeingCompiled: string[] // Used to detect cyclic references\n  }): Promise<{ compiledQuery: string; resolvedParams: ResolvedParam[] }> {\n    const fullQueryName = this.fullQueryPath(request.queryPath)\n    queriesBeingCompiled.push(fullQueryName)\n\n    const query = this.readQuery(fullQueryName)\n    const params = request.params || {}\n    const resolveFn = async (value: unknown): Promise<string> => {\n      const resolved = this.resolve(value, resolvedParams.length)\n      resolvedParams.push(resolved)\n      return resolved.resolvedAs\n    }\n    const supportedMethods = this.buildSupportedMethods({\n      params,\n      resolveFn,\n      ranQueries,\n      queriesBeingCompiled,\n    })\n    const compiledQuery = await compile({\n      query,\n      resolveFn,\n      supportedMethods,\n    })\n\n    // NOTE: To avoid compiling subqueries that have already been compiled in\n    // the current call stack.\n    queriesBeingCompiled.pop()\n\n    return {\n      compiledQuery,\n      resolvedParams,\n    }\n  }\n\n  private fullQueryPath(queryName: string): string {\n    return path.join(\n      this.rootPath,\n      queryName.endsWith('.sql') ? queryName : `${queryName}.sql`,\n    )\n  }\n\n  private readQuery(fullQueryPath: string): string {\n    if (!fs.existsSync(fullQueryPath))\n      throw new ConnectorError(`Query file not found: ${fullQueryPath}`)\n    return fs.readFileSync(fullQueryPath, 'utf8')\n  }\n\n  private buildSupportedMethods({\n    params,\n    resolveFn,\n    ranQueries,\n    queriesBeingCompiled,\n  }: {\n    params: QueryParams\n    resolveFn: (value: unknown) => Promise<string>\n    ranQueries: Record<string, QueryResultArray>\n    queriesBeingCompiled: string[]\n  }): Record<string, SupportedMethod> {\n    const supportedMethods = {\n      interpolate: async <T extends boolean>(\n        interpolation: T,\n        value: unknown,\n      ): Promise<string> => {\n        if (!interpolation) {\n          throw new Error(\n            'interpolate function cannot be used inside a logic block',\n          )\n        }\n        return String(value)\n      },\n      param: async <T extends boolean>(\n        interpolation: T,\n        name: unknown,\n        defaultValue?: unknown,\n      ): Promise<T extends true ? string : unknown> => {\n        if (typeof name !== 'string') throw new Error('Invalid parameter name')\n        if (!(name in params) && defaultValue === undefined) {\n          throw new Error(`Missing parameter '${name}' in request`)\n        }\n        const value = name in params ? params[name] : defaultValue\n\n        const resolvedValue = interpolation ? await resolveFn(value) : value\n        return resolvedValue as T extends true ? string : unknown\n      },\n      unsafeParam: async <T extends boolean>(\n        interpolation: T,\n        name: unknown,\n        defaultValue?: unknown,\n      ): Promise<T extends true ? string : unknown> => {\n        if (!interpolation) {\n          throw new Error(\n            'unsafeParam function cannot be used inside a logic block',\n          )\n        }\n        if (typeof name !== 'string') throw new Error('Invalid parameter name')\n        if (!(name in params) && defaultValue === undefined) {\n          throw new Error(`Missing parameter '${name}' in request`)\n        }\n        const value = name in params ? params[name] : defaultValue\n\n        return String(value)\n      },\n      cast: async <T extends boolean>(\n        interpolation: T,\n        value: unknown,\n        type: unknown,\n      ): Promise<T extends true ? string : unknown> => {\n        if (typeof type !== 'string') throw new Error('Invalid cast type')\n        if (!(type in CAST_METHODS)) {\n          throw new Error(`Unsupported cast type: '${type}'`)\n        }\n        const parsedValue = CAST_METHODS[type]!(value)\n\n        const resolvedValue = interpolation\n          ? await resolveFn(parsedValue)\n          : parsedValue\n        return resolvedValue as T extends true ? string : unknown\n      },\n      ref: async <T extends boolean>(\n        interpolation: T,\n        queryName: unknown,\n      ): Promise<T extends true ? string : unknown> => {\n        if (typeof queryName !== 'string') throw new Error('Invalid query name')\n        if (!interpolation) {\n          throw new Error('ref function cannot be used inside a logic block')\n        }\n        const fullSubQueryPath = this.fullQueryPath(queryName)\n        if (queriesBeingCompiled.includes(fullSubQueryPath)) {\n          throw new Error(\n            'Query reference to a parent, resulting in cyclic references.',\n          )\n        }\n\n        queriesBeingCompiled.push(fullSubQueryPath)\n        const subQuery = this.readQuery(fullSubQueryPath)\n\n        const compiledSubQuery = await compile({\n          query: subQuery,\n          resolveFn,\n          supportedMethods,\n        })\n        queriesBeingCompiled.pop()\n\n        return `(${compiledSubQuery})`\n      },\n      runQuery: async <T extends boolean>(\n        interpolation: T,\n        queryName: unknown,\n      ): Promise<T extends true ? string : QueryResultArray> => {\n        if (typeof queryName !== 'string') throw new Error('Invalid query name')\n        if (interpolation) {\n          throw new Error(\n            'runQuery function cannot be directly interpolated into the query',\n          )\n        }\n        const fullSubQueryPath = this.fullQueryPath(queryName)\n        if (fullSubQueryPath in ranQueries) {\n          return ranQueries[fullSubQueryPath] as T extends true\n            ? string\n            : QueryResultArray\n        }\n        if (queriesBeingCompiled.includes(fullSubQueryPath)) {\n          throw new Error(\n            'Query reference to a parent, resulting in cyclic references.',\n          )\n        }\n\n        const subQueryResults = (\n          await this._query({\n            request: { queryPath: queryName, params },\n            resolvedParams: [],\n            ranQueries,\n            queriesBeingCompiled,\n          })\n        ).toArray()\n        ranQueries[fullSubQueryPath] = subQueryResults\n        return subQueryResults as T extends true ? string : QueryResultArray\n      },\n    }\n\n    return supportedMethods\n  }\n}\n\nexport const CAST_METHODS: {\n  [type: string]: (value: any) => unknown\n} = {\n  string: (value) => String(value),\n  text: (value) => String(value),\n  int: (value) => parseInt(value),\n  float: (value) => parseFloat(value),\n  number: (value) => Number(value),\n  bool: (value) => Boolean(value),\n  boolean: (value) => Boolean(value),\n  date: (value) => new Date(value),\n}\n\nexport * from './types'\nexport { CompileError }\n"],"names":[],"mappings":"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"}