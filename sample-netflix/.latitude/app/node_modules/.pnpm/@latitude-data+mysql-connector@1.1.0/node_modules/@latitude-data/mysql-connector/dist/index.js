import { BaseConnector, ConnectionError, QueryError } from '@latitude-data/base-connector';
import { readFileSync } from 'fs';
import { createPool } from 'mysql';
import QueryResult, { DataType } from '@latitude-data/query_result';

class MysqlConnector extends BaseConnector {
    pool;
    constructor(rootPath, connectionParams) {
        super(rootPath);
        this.pool = createPool({
            connectionLimit: 10,
            ...this.buildConnectionParams(connectionParams),
        });
    }
    resolve(value, _) {
        return {
            value,
            resolvedAs: '?',
        };
    }
    runQuery(query) {
        return new Promise((resolve, reject) => {
            this.pool.getConnection((err, connection) => {
                if (err) {
                    return reject(new ConnectionError(err.message));
                }
                connection.query(query.sql, this.buildQueryParams(query.params), (error, results, fields) => {
                    connection.release();
                    if (error) {
                        return reject(new QueryError(error.message));
                    }
                    resolve(new QueryResult({
                        rowCount: results.length,
                        fields: (fields ?? [])?.map((field) => ({
                            name: field.name,
                            type: this.convertDataType(field.type),
                        })),
                        rows: results.map((row) => row ? Object.values(row) : []),
                    }));
                });
            });
        });
    }
    buildConnectionParams(params) {
        const payload = {
            host: params.host,
            user: params.user,
            password: params.password,
            database: params.database,
            ssl: params.ssl !== undefined ? this.buildSSLConfig(params.ssl) : undefined,
        };
        return this.compact(payload);
    }
    buildSSLConfig(ssl) {
        if (ssl === 'Amazon RDS')
            return 'Amazon RDS';
        if (typeof ssl === 'boolean') {
            if (ssl)
                return {};
            else
                return undefined;
        }
        const { ca, key, cert, rejectUnauthorized } = ssl;
        const payload = {
            rejectUnauthorized,
            ca: ca ? this.readSecureFile(ca) : undefined,
            key: key ? this.readSecureFile(key) : undefined,
            cert: cert ? this.readSecureFile(cert) : undefined,
        };
        return this.compact(payload);
    }
    readSecureFile(filePath) {
        try {
            return readFileSync(filePath).toString();
        }
        catch (error) {
            throw new Error(`Failed to read file at ${filePath}: ${error.message}`);
        }
    }
    compact(obj) {
        return Object.fromEntries(Object.entries(obj).filter(([, value]) => value !== undefined));
    }
    buildQueryParams(params) {
        return params.map((param) => param.value);
    }
    convertDataType(dataTypeID, fallbackType = DataType.Unknown) {
        switch (dataTypeID) {
            case 15 /* Types.VARCHAR */:
            case 253 /* Types.VAR_STRING */:
            case 254 /* Types.STRING */:
                return DataType.String;
            case 1 /* Types.TINY */:
            case 2 /* Types.SHORT */:
            case 3 /* Types.LONG */:
            case 9 /* Types.INT24 */:
                return DataType.Integer;
            case 0 /* Types.DECIMAL */:
            case 4 /* Types.FLOAT */:
            case 5 /* Types.DOUBLE */:
            case 246 /* Types.NEWDECIMAL */:
                return DataType.Float;
            case 11 /* Types.TIME */:
            case 19 /* Types.TIME2 */:
            case 17 /* Types.TIMESTAMP2 */:
            case 12 /* Types.DATETIME */:
            case 18 /* Types.DATETIME2 */:
            case 13 /* Types.YEAR */:
            case 14 /* Types.NEWDATE */:
            case 7 /* Types.TIMESTAMP */:
                return DataType.Datetime;
            case 252 /* Types.BLOB */:
            case 249 /* Types.TINY_BLOB */:
            case 250 /* Types.MEDIUM_BLOB */:
            case 251 /* Types.LONG_BLOB */:
            case 247 /* Types.ENUM */:
            case 245 /* Types.JSON */:
            case 248 /* Types.SET */:
            case 6 /* Types.NULL */:
            case 255 /* Types.GEOMETRY */:
            case 16 /* Types.BIT */:
                return fallbackType;
        }
    }
}

export { MysqlConnector };
//# sourceMappingURL=index.js.map
