"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const apache_arrow_1 = require("apache-arrow");
const utils_1 = require("./utils");
const { isArrowBigNumSymbol, bigNumToBigInt } = apache_arrow_1.util;
class ArrowResultConverter {
    constructor(context, source, { schema }) {
        this.context = context;
        this.source = source;
        this.schema = (0, utils_1.getSchemaColumns)(schema);
    }
    hasMore() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.schema.length === 0) {
                return false;
            }
            if (this.pendingRecordBatch) {
                return true;
            }
            return this.source.hasMore();
        });
    }
    fetchNext(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.schema.length === 0) {
                return [];
            }
            // eslint-disable-next-line no-constant-condition
            while (true) {
                // It's not possible to know if iterator has more items until trying
                // to get the next item. But we need to know if iterator is empty right
                // after getting the next item. Therefore, after creating the iterator,
                // we get one item more and store it in `pendingRecordBatch`. Next time,
                // we use that stored item, and prefetch the next one. Prefetched item
                // is therefore the next item we are going to return, so it can be used
                // to know if we actually can return anything next time
                const recordBatch = this.pendingRecordBatch;
                this.pendingRecordBatch = this.prefetch();
                if (recordBatch) {
                    const table = new apache_arrow_1.Table(recordBatch);
                    return this.getRows(table.schema, table.toArray());
                }
                // eslint-disable-next-line no-await-in-loop
                const batches = yield this.source.fetchNext(options);
                if (batches.length === 0) {
                    this.reader = undefined;
                    break;
                }
                const reader = apache_arrow_1.RecordBatchReader.from(batches);
                this.reader = reader[Symbol.iterator]();
                this.pendingRecordBatch = this.prefetch();
            }
            return [];
        });
    }
    prefetch() {
        var _a, _b;
        const item = (_b = (_a = this.reader) === null || _a === void 0 ? void 0 : _a.next()) !== null && _b !== void 0 ? _b : { done: true, value: undefined };
        if (item.done || item.value === undefined) {
            this.reader = undefined;
            return undefined;
        }
        return item.value;
    }
    getRows(schema, rows) {
        return rows.map((row) => {
            // First, convert native Arrow values to corresponding plain JS objects
            const record = this.convertArrowTypes(row, undefined, schema.fields);
            // Second, cast all the values to original Thrift types
            return this.convertThriftTypes(record);
        });
    }
    convertArrowTypes(value, valueType, fields = []) {
        var _a;
        if (value === null) {
            return value;
        }
        const fieldsMap = {};
        for (const field of fields) {
            fieldsMap[field.name] = field;
        }
        // Convert structures to plain JS object and process all its fields recursively
        if (value instanceof apache_arrow_1.StructRow) {
            const result = value.toJSON();
            for (const key of Object.keys(result)) {
                const field = fieldsMap[key];
                result[key] = this.convertArrowTypes(result[key], field === null || field === void 0 ? void 0 : field.type, (field === null || field === void 0 ? void 0 : field.type.children) || []);
            }
            return result;
        }
        if (value instanceof apache_arrow_1.MapRow) {
            const result = value.toJSON();
            // Map type consists of its key and value types. We need only value type here, key will be cast to string anyway
            const field = (_a = fieldsMap.entries) === null || _a === void 0 ? void 0 : _a.type.children.find((item) => item.name === 'value');
            for (const key of Object.keys(result)) {
                result[key] = this.convertArrowTypes(result[key], field === null || field === void 0 ? void 0 : field.type, (field === null || field === void 0 ? void 0 : field.type.children) || []);
            }
            return result;
        }
        // Convert lists to JS array and process items recursively
        if (value instanceof apache_arrow_1.Vector) {
            const result = value.toJSON();
            // Array type contains the only child which defines a type of each array's element
            const field = fieldsMap.element;
            return result.map((item) => this.convertArrowTypes(item, field === null || field === void 0 ? void 0 : field.type, (field === null || field === void 0 ? void 0 : field.type.children) || []));
        }
        if (apache_arrow_1.DataType.isTimestamp(valueType)) {
            return new Date(value);
        }
        // Convert big number values to BigInt
        // Decimals are also represented as big numbers in Arrow, so additionally process them (convert to float)
        if (value instanceof Object && value[isArrowBigNumSymbol]) {
            const result = bigNumToBigInt(value);
            if (apache_arrow_1.DataType.isDecimal(valueType)) {
                return Number(result) / Math.pow(10, valueType.scale);
            }
            return result;
        }
        // Convert binary data to Buffer
        if (value instanceof Uint8Array) {
            return buffer_1.Buffer.from(value);
        }
        // Return other values as is
        return typeof value === 'bigint' ? Number(value) : value;
    }
    convertThriftTypes(record) {
        const result = {};
        this.schema.forEach((column) => {
            var _a;
            const typeDescriptor = (_a = column.typeDesc.types[0]) === null || _a === void 0 ? void 0 : _a.primitiveEntry;
            const field = column.columnName;
            const value = record[field];
            result[field] = value === null ? null : (0, utils_1.convertThriftValue)(typeDescriptor, value);
        });
        return result;
    }
}
exports.default = ArrowResultConverter;
//# sourceMappingURL=ArrowResultConverter.js.map